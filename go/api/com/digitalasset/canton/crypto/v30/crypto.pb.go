// Copyright (c) 2017-2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.30.0
// source: com/digitalasset/canton/crypto/v30/crypto.proto

package v30

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HashAlgorithm int32

const (
	HashAlgorithm_HASH_ALGORITHM_UNSPECIFIED HashAlgorithm = 0
	HashAlgorithm_HASH_ALGORITHM_SHA256      HashAlgorithm = 1
)

// Enum value maps for HashAlgorithm.
var (
	HashAlgorithm_name = map[int32]string{
		0: "HASH_ALGORITHM_UNSPECIFIED",
		1: "HASH_ALGORITHM_SHA256",
	}
	HashAlgorithm_value = map[string]int32{
		"HASH_ALGORITHM_UNSPECIFIED": 0,
		"HASH_ALGORITHM_SHA256":      1,
	}
)

func (x HashAlgorithm) Enum() *HashAlgorithm {
	p := new(HashAlgorithm)
	*p = x
	return p
}

func (x HashAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HashAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[0].Descriptor()
}

func (HashAlgorithm) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[0]
}

func (x HashAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HashAlgorithm.Descriptor instead.
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{0}
}

type HmacAlgorithm int32

const (
	HmacAlgorithm_HMAC_ALGORITHM_UNSPECIFIED HmacAlgorithm = 0
	HmacAlgorithm_HMAC_ALGORITHM_HMAC_SHA256 HmacAlgorithm = 1
)

// Enum value maps for HmacAlgorithm.
var (
	HmacAlgorithm_name = map[int32]string{
		0: "HMAC_ALGORITHM_UNSPECIFIED",
		1: "HMAC_ALGORITHM_HMAC_SHA256",
	}
	HmacAlgorithm_value = map[string]int32{
		"HMAC_ALGORITHM_UNSPECIFIED": 0,
		"HMAC_ALGORITHM_HMAC_SHA256": 1,
	}
)

func (x HmacAlgorithm) Enum() *HmacAlgorithm {
	p := new(HmacAlgorithm)
	*p = x
	return p
}

func (x HmacAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HmacAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[1].Descriptor()
}

func (HmacAlgorithm) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[1]
}

func (x HmacAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HmacAlgorithm.Descriptor instead.
func (HmacAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{1}
}

type SignatureFormat int32

const (
	SignatureFormat_SIGNATURE_FORMAT_UNSPECIFIED SignatureFormat = 0
	SignatureFormat_SIGNATURE_FORMAT_RAW         SignatureFormat = 1
	SignatureFormat_SIGNATURE_FORMAT_DER         SignatureFormat = 2
	SignatureFormat_SIGNATURE_FORMAT_CONCAT      SignatureFormat = 3
	SignatureFormat_SIGNATURE_FORMAT_SYMBOLIC    SignatureFormat = 10000
)

// Enum value maps for SignatureFormat.
var (
	SignatureFormat_name = map[int32]string{
		0:     "SIGNATURE_FORMAT_UNSPECIFIED",
		1:     "SIGNATURE_FORMAT_RAW",
		2:     "SIGNATURE_FORMAT_DER",
		3:     "SIGNATURE_FORMAT_CONCAT",
		10000: "SIGNATURE_FORMAT_SYMBOLIC",
	}
	SignatureFormat_value = map[string]int32{
		"SIGNATURE_FORMAT_UNSPECIFIED": 0,
		"SIGNATURE_FORMAT_RAW":         1,
		"SIGNATURE_FORMAT_DER":         2,
		"SIGNATURE_FORMAT_CONCAT":      3,
		"SIGNATURE_FORMAT_SYMBOLIC":    10000,
	}
)

func (x SignatureFormat) Enum() *SignatureFormat {
	p := new(SignatureFormat)
	*p = x
	return p
}

func (x SignatureFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignatureFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[2].Descriptor()
}

func (SignatureFormat) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[2]
}

func (x SignatureFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SignatureFormat.Descriptor instead.
func (SignatureFormat) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{2}
}

type EncryptionKeySpec int32

const (
	EncryptionKeySpec_ENCRYPTION_KEY_SPEC_UNSPECIFIED EncryptionKeySpec = 0
	EncryptionKeySpec_ENCRYPTION_KEY_SPEC_EC_P256     EncryptionKeySpec = 1
	EncryptionKeySpec_ENCRYPTION_KEY_SPEC_RSA_2048    EncryptionKeySpec = 2
)

// Enum value maps for EncryptionKeySpec.
var (
	EncryptionKeySpec_name = map[int32]string{
		0: "ENCRYPTION_KEY_SPEC_UNSPECIFIED",
		1: "ENCRYPTION_KEY_SPEC_EC_P256",
		2: "ENCRYPTION_KEY_SPEC_RSA_2048",
	}
	EncryptionKeySpec_value = map[string]int32{
		"ENCRYPTION_KEY_SPEC_UNSPECIFIED": 0,
		"ENCRYPTION_KEY_SPEC_EC_P256":     1,
		"ENCRYPTION_KEY_SPEC_RSA_2048":    2,
	}
)

func (x EncryptionKeySpec) Enum() *EncryptionKeySpec {
	p := new(EncryptionKeySpec)
	*p = x
	return p
}

func (x EncryptionKeySpec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionKeySpec) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[3].Descriptor()
}

func (EncryptionKeySpec) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[3]
}

func (x EncryptionKeySpec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionKeySpec.Descriptor instead.
func (EncryptionKeySpec) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{3}
}

type SigningKeySpec int32

const (
	SigningKeySpec_SIGNING_KEY_SPEC_UNSPECIFIED   SigningKeySpec = 0
	SigningKeySpec_SIGNING_KEY_SPEC_EC_CURVE25519 SigningKeySpec = 1
	SigningKeySpec_SIGNING_KEY_SPEC_EC_P256       SigningKeySpec = 2
	SigningKeySpec_SIGNING_KEY_SPEC_EC_P384       SigningKeySpec = 3
	SigningKeySpec_SIGNING_KEY_SPEC_EC_SECP256K1  SigningKeySpec = 4
)

// Enum value maps for SigningKeySpec.
var (
	SigningKeySpec_name = map[int32]string{
		0: "SIGNING_KEY_SPEC_UNSPECIFIED",
		1: "SIGNING_KEY_SPEC_EC_CURVE25519",
		2: "SIGNING_KEY_SPEC_EC_P256",
		3: "SIGNING_KEY_SPEC_EC_P384",
		4: "SIGNING_KEY_SPEC_EC_SECP256K1",
	}
	SigningKeySpec_value = map[string]int32{
		"SIGNING_KEY_SPEC_UNSPECIFIED":   0,
		"SIGNING_KEY_SPEC_EC_CURVE25519": 1,
		"SIGNING_KEY_SPEC_EC_P256":       2,
		"SIGNING_KEY_SPEC_EC_P384":       3,
		"SIGNING_KEY_SPEC_EC_SECP256K1":  4,
	}
)

func (x SigningKeySpec) Enum() *SigningKeySpec {
	p := new(SigningKeySpec)
	*p = x
	return p
}

func (x SigningKeySpec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningKeySpec) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[4].Descriptor()
}

func (SigningKeySpec) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[4]
}

func (x SigningKeySpec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningKeySpec.Descriptor instead.
func (SigningKeySpec) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{4}
}

type KeyPurpose int32

const (
	KeyPurpose_KEY_PURPOSE_UNSPECIFIED KeyPurpose = 0
	KeyPurpose_KEY_PURPOSE_SIGNING     KeyPurpose = 1
	KeyPurpose_KEY_PURPOSE_ENCRYPTION  KeyPurpose = 2
)

// Enum value maps for KeyPurpose.
var (
	KeyPurpose_name = map[int32]string{
		0: "KEY_PURPOSE_UNSPECIFIED",
		1: "KEY_PURPOSE_SIGNING",
		2: "KEY_PURPOSE_ENCRYPTION",
	}
	KeyPurpose_value = map[string]int32{
		"KEY_PURPOSE_UNSPECIFIED": 0,
		"KEY_PURPOSE_SIGNING":     1,
		"KEY_PURPOSE_ENCRYPTION":  2,
	}
)

func (x KeyPurpose) Enum() *KeyPurpose {
	p := new(KeyPurpose)
	*p = x
	return p
}

func (x KeyPurpose) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyPurpose) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[5].Descriptor()
}

func (KeyPurpose) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[5]
}

func (x KeyPurpose) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyPurpose.Descriptor instead.
func (KeyPurpose) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{5}
}

type SigningKeyUsage int32

const (
	SigningKeyUsage_SIGNING_KEY_USAGE_UNSPECIFIED SigningKeyUsage = 0
	SigningKeyUsage_SIGNING_KEY_USAGE_NAMESPACE   SigningKeyUsage = 1
	// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
	SigningKeyUsage_SIGNING_KEY_USAGE_IDENTITY_DELEGATION      SigningKeyUsage = 2
	SigningKeyUsage_SIGNING_KEY_USAGE_SEQUENCER_AUTHENTICATION SigningKeyUsage = 3
	SigningKeyUsage_SIGNING_KEY_USAGE_PROTOCOL                 SigningKeyUsage = 4
	SigningKeyUsage_SIGNING_KEY_USAGE_PROOF_OF_OWNERSHIP       SigningKeyUsage = 5
)

// Enum value maps for SigningKeyUsage.
var (
	SigningKeyUsage_name = map[int32]string{
		0: "SIGNING_KEY_USAGE_UNSPECIFIED",
		1: "SIGNING_KEY_USAGE_NAMESPACE",
		2: "SIGNING_KEY_USAGE_IDENTITY_DELEGATION",
		3: "SIGNING_KEY_USAGE_SEQUENCER_AUTHENTICATION",
		4: "SIGNING_KEY_USAGE_PROTOCOL",
		5: "SIGNING_KEY_USAGE_PROOF_OF_OWNERSHIP",
	}
	SigningKeyUsage_value = map[string]int32{
		"SIGNING_KEY_USAGE_UNSPECIFIED":              0,
		"SIGNING_KEY_USAGE_NAMESPACE":                1,
		"SIGNING_KEY_USAGE_IDENTITY_DELEGATION":      2,
		"SIGNING_KEY_USAGE_SEQUENCER_AUTHENTICATION": 3,
		"SIGNING_KEY_USAGE_PROTOCOL":                 4,
		"SIGNING_KEY_USAGE_PROOF_OF_OWNERSHIP":       5,
	}
)

func (x SigningKeyUsage) Enum() *SigningKeyUsage {
	p := new(SigningKeyUsage)
	*p = x
	return p
}

func (x SigningKeyUsage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningKeyUsage) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[6].Descriptor()
}

func (SigningKeyUsage) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[6]
}

func (x SigningKeyUsage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningKeyUsage.Descriptor instead.
func (SigningKeyUsage) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{6}
}

type SigningAlgorithmSpec int32

const (
	SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_UNSPECIFIED    SigningAlgorithmSpec = 0
	SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_ED25519        SigningAlgorithmSpec = 1
	SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256 SigningAlgorithmSpec = 2
	SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384 SigningAlgorithmSpec = 3
)

// Enum value maps for SigningAlgorithmSpec.
var (
	SigningAlgorithmSpec_name = map[int32]string{
		0: "SIGNING_ALGORITHM_SPEC_UNSPECIFIED",
		1: "SIGNING_ALGORITHM_SPEC_ED25519",
		2: "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256",
		3: "SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384",
	}
	SigningAlgorithmSpec_value = map[string]int32{
		"SIGNING_ALGORITHM_SPEC_UNSPECIFIED":    0,
		"SIGNING_ALGORITHM_SPEC_ED25519":        1,
		"SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256": 2,
		"SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384": 3,
	}
)

func (x SigningAlgorithmSpec) Enum() *SigningAlgorithmSpec {
	p := new(SigningAlgorithmSpec)
	*p = x
	return p
}

func (x SigningAlgorithmSpec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningAlgorithmSpec) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[7].Descriptor()
}

func (SigningAlgorithmSpec) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[7]
}

func (x SigningAlgorithmSpec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningAlgorithmSpec.Descriptor instead.
func (SigningAlgorithmSpec) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{7}
}

type SigningKeyScheme int32

const (
	SigningKeyScheme_SIGNING_KEY_SCHEME_UNSPECIFIED SigningKeyScheme = 0
	SigningKeyScheme_SIGNING_KEY_SCHEME_ED25519     SigningKeyScheme = 1
	SigningKeyScheme_SIGNING_KEY_SCHEME_EC_DSA_P256 SigningKeyScheme = 2
	SigningKeyScheme_SIGNING_KEY_SCHEME_EC_DSA_P384 SigningKeyScheme = 3
)

// Enum value maps for SigningKeyScheme.
var (
	SigningKeyScheme_name = map[int32]string{
		0: "SIGNING_KEY_SCHEME_UNSPECIFIED",
		1: "SIGNING_KEY_SCHEME_ED25519",
		2: "SIGNING_KEY_SCHEME_EC_DSA_P256",
		3: "SIGNING_KEY_SCHEME_EC_DSA_P384",
	}
	SigningKeyScheme_value = map[string]int32{
		"SIGNING_KEY_SCHEME_UNSPECIFIED": 0,
		"SIGNING_KEY_SCHEME_ED25519":     1,
		"SIGNING_KEY_SCHEME_EC_DSA_P256": 2,
		"SIGNING_KEY_SCHEME_EC_DSA_P384": 3,
	}
)

func (x SigningKeyScheme) Enum() *SigningKeyScheme {
	p := new(SigningKeyScheme)
	*p = x
	return p
}

func (x SigningKeyScheme) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SigningKeyScheme) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[8].Descriptor()
}

func (SigningKeyScheme) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[8]
}

func (x SigningKeyScheme) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SigningKeyScheme.Descriptor instead.
func (SigningKeyScheme) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{8}
}

type EncryptionAlgorithmSpec int32

const (
	EncryptionAlgorithmSpec_ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED                      EncryptionAlgorithmSpec = 0
	EncryptionAlgorithmSpec_ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128GCM EncryptionAlgorithmSpec = 1
	EncryptionAlgorithmSpec_ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128CBC EncryptionAlgorithmSpec = 2
	EncryptionAlgorithmSpec_ENCRYPTION_ALGORITHM_SPEC_RSA_OAEP_SHA256                  EncryptionAlgorithmSpec = 3
)

// Enum value maps for EncryptionAlgorithmSpec.
var (
	EncryptionAlgorithmSpec_name = map[int32]string{
		0: "ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED",
		1: "ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128GCM",
		2: "ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128CBC",
		3: "ENCRYPTION_ALGORITHM_SPEC_RSA_OAEP_SHA256",
	}
	EncryptionAlgorithmSpec_value = map[string]int32{
		"ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED":                      0,
		"ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128GCM": 1,
		"ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128CBC": 2,
		"ENCRYPTION_ALGORITHM_SPEC_RSA_OAEP_SHA256":                  3,
	}
)

func (x EncryptionAlgorithmSpec) Enum() *EncryptionAlgorithmSpec {
	p := new(EncryptionAlgorithmSpec)
	*p = x
	return p
}

func (x EncryptionAlgorithmSpec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionAlgorithmSpec) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[9].Descriptor()
}

func (EncryptionAlgorithmSpec) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[9]
}

func (x EncryptionAlgorithmSpec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionAlgorithmSpec.Descriptor instead.
func (EncryptionAlgorithmSpec) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{9}
}

type EncryptionKeyScheme int32

const (
	EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_UNSPECIFIED                           EncryptionKeyScheme = 0
	EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_ECIES_P256_HKDF_HMAC_SHA256_AES128GCM EncryptionKeyScheme = 1
	EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_ECIES_P256_HMAC_SHA256A_ES128CBC      EncryptionKeyScheme = 2
	EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_RSA2048_OAEP_SHA256                   EncryptionKeyScheme = 3
)

// Enum value maps for EncryptionKeyScheme.
var (
	EncryptionKeyScheme_name = map[int32]string{
		0: "ENCRYPTION_KEY_SCHEME_UNSPECIFIED",
		1: "ENCRYPTION_KEY_SCHEME_ECIES_P256_HKDF_HMAC_SHA256_AES128GCM",
		2: "ENCRYPTION_KEY_SCHEME_ECIES_P256_HMAC_SHA256A_ES128CBC",
		3: "ENCRYPTION_KEY_SCHEME_RSA2048_OAEP_SHA256",
	}
	EncryptionKeyScheme_value = map[string]int32{
		"ENCRYPTION_KEY_SCHEME_UNSPECIFIED":                           0,
		"ENCRYPTION_KEY_SCHEME_ECIES_P256_HKDF_HMAC_SHA256_AES128GCM": 1,
		"ENCRYPTION_KEY_SCHEME_ECIES_P256_HMAC_SHA256A_ES128CBC":      2,
		"ENCRYPTION_KEY_SCHEME_RSA2048_OAEP_SHA256":                   3,
	}
)

func (x EncryptionKeyScheme) Enum() *EncryptionKeyScheme {
	p := new(EncryptionKeyScheme)
	*p = x
	return p
}

func (x EncryptionKeyScheme) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncryptionKeyScheme) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[10].Descriptor()
}

func (EncryptionKeyScheme) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[10]
}

func (x EncryptionKeyScheme) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncryptionKeyScheme.Descriptor instead.
func (EncryptionKeyScheme) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{10}
}

type SymmetricKeyScheme int32

const (
	SymmetricKeyScheme_SYMMETRIC_KEY_SCHEME_UNSPECIFIED SymmetricKeyScheme = 0
	SymmetricKeyScheme_SYMMETRIC_KEY_SCHEME_AES128GCM   SymmetricKeyScheme = 1
)

// Enum value maps for SymmetricKeyScheme.
var (
	SymmetricKeyScheme_name = map[int32]string{
		0: "SYMMETRIC_KEY_SCHEME_UNSPECIFIED",
		1: "SYMMETRIC_KEY_SCHEME_AES128GCM",
	}
	SymmetricKeyScheme_value = map[string]int32{
		"SYMMETRIC_KEY_SCHEME_UNSPECIFIED": 0,
		"SYMMETRIC_KEY_SCHEME_AES128GCM":   1,
	}
)

func (x SymmetricKeyScheme) Enum() *SymmetricKeyScheme {
	p := new(SymmetricKeyScheme)
	*p = x
	return p
}

func (x SymmetricKeyScheme) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SymmetricKeyScheme) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[11].Descriptor()
}

func (SymmetricKeyScheme) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[11]
}

func (x SymmetricKeyScheme) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SymmetricKeyScheme.Descriptor instead.
func (SymmetricKeyScheme) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{11}
}

type CryptoKeyFormat int32

const (
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED                      CryptoKeyFormat = 0
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_DER                              CryptoKeyFormat = 2
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_RAW                              CryptoKeyFormat = 3
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO CryptoKeyFormat = 4
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_DER_PKCS8_PRIVATE_KEY_INFO       CryptoKeyFormat = 5
	CryptoKeyFormat_CRYPTO_KEY_FORMAT_SYMBOLIC                         CryptoKeyFormat = 10000
)

// Enum value maps for CryptoKeyFormat.
var (
	CryptoKeyFormat_name = map[int32]string{
		0:     "CRYPTO_KEY_FORMAT_UNSPECIFIED",
		2:     "CRYPTO_KEY_FORMAT_DER",
		3:     "CRYPTO_KEY_FORMAT_RAW",
		4:     "CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO",
		5:     "CRYPTO_KEY_FORMAT_DER_PKCS8_PRIVATE_KEY_INFO",
		10000: "CRYPTO_KEY_FORMAT_SYMBOLIC",
	}
	CryptoKeyFormat_value = map[string]int32{
		"CRYPTO_KEY_FORMAT_UNSPECIFIED":                      0,
		"CRYPTO_KEY_FORMAT_DER":                              2,
		"CRYPTO_KEY_FORMAT_RAW":                              3,
		"CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO": 4,
		"CRYPTO_KEY_FORMAT_DER_PKCS8_PRIVATE_KEY_INFO":       5,
		"CRYPTO_KEY_FORMAT_SYMBOLIC":                         10000,
	}
)

func (x CryptoKeyFormat) Enum() *CryptoKeyFormat {
	p := new(CryptoKeyFormat)
	*p = x
	return p
}

func (x CryptoKeyFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CryptoKeyFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[12].Descriptor()
}

func (CryptoKeyFormat) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[12]
}

func (x CryptoKeyFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CryptoKeyFormat.Descriptor instead.
func (CryptoKeyFormat) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{12}
}

type PbkdfScheme int32

const (
	PbkdfScheme_PBKDF_SCHEME_UNSPECIFIED    PbkdfScheme = 0
	PbkdfScheme_PBKDF_SCHEME_ARGON2ID_MODE1 PbkdfScheme = 1
)

// Enum value maps for PbkdfScheme.
var (
	PbkdfScheme_name = map[int32]string{
		0: "PBKDF_SCHEME_UNSPECIFIED",
		1: "PBKDF_SCHEME_ARGON2ID_MODE1",
	}
	PbkdfScheme_value = map[string]int32{
		"PBKDF_SCHEME_UNSPECIFIED":    0,
		"PBKDF_SCHEME_ARGON2ID_MODE1": 1,
	}
)

func (x PbkdfScheme) Enum() *PbkdfScheme {
	p := new(PbkdfScheme)
	*p = x
	return p
}

func (x PbkdfScheme) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PbkdfScheme) Descriptor() protoreflect.EnumDescriptor {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[13].Descriptor()
}

func (PbkdfScheme) Type() protoreflect.EnumType {
	return &file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes[13]
}

func (x PbkdfScheme) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PbkdfScheme.Descriptor instead.
func (PbkdfScheme) EnumDescriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{13}
}

type Hmac struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Algorithm     HmacAlgorithm          `protobuf:"varint,1,opt,name=algorithm,proto3,enum=com.digitalasset.canton.crypto.v30.HmacAlgorithm" json:"algorithm,omitempty"`
	Hmac          []byte                 `protobuf:"bytes,2,opt,name=hmac,proto3" json:"hmac,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Hmac) Reset() {
	*x = Hmac{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Hmac) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Hmac) ProtoMessage() {}

func (x *Hmac) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Hmac.ProtoReflect.Descriptor instead.
func (*Hmac) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{0}
}

func (x *Hmac) GetAlgorithm() HmacAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return HmacAlgorithm_HMAC_ALGORITHM_UNSPECIFIED
}

func (x *Hmac) GetHmac() []byte {
	if x != nil {
		return x.Hmac
	}
	return nil
}

type Salt struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Algorithm:
	//
	//	*Salt_Hmac
	Algorithm     isSalt_Algorithm `protobuf_oneof:"algorithm"`
	Salt          []byte           `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Salt) Reset() {
	*x = Salt{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Salt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Salt) ProtoMessage() {}

func (x *Salt) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Salt.ProtoReflect.Descriptor instead.
func (*Salt) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{1}
}

func (x *Salt) GetAlgorithm() isSalt_Algorithm {
	if x != nil {
		return x.Algorithm
	}
	return nil
}

func (x *Salt) GetHmac() HmacAlgorithm {
	if x != nil {
		if x, ok := x.Algorithm.(*Salt_Hmac); ok {
			return x.Hmac
		}
	}
	return HmacAlgorithm_HMAC_ALGORITHM_UNSPECIFIED
}

func (x *Salt) GetSalt() []byte {
	if x != nil {
		return x.Salt
	}
	return nil
}

type isSalt_Algorithm interface {
	isSalt_Algorithm()
}

type Salt_Hmac struct {
	Hmac HmacAlgorithm `protobuf:"varint,1,opt,name=hmac,proto3,enum=com.digitalasset.canton.crypto.v30.HmacAlgorithm,oneof"`
}

func (*Salt_Hmac) isSalt_Algorithm() {}

type Signature struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Format               SignatureFormat        `protobuf:"varint,1,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.SignatureFormat" json:"format,omitempty"`
	Signature            []byte                 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	SignedBy             string                 `protobuf:"bytes,3,opt,name=signed_by,json=signedBy,proto3" json:"signed_by,omitempty"`
	SigningAlgorithmSpec SigningAlgorithmSpec   `protobuf:"varint,4,opt,name=signing_algorithm_spec,json=signingAlgorithmSpec,proto3,enum=com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec" json:"signing_algorithm_spec,omitempty"`
	SignatureDelegation  *SignatureDelegation   `protobuf:"bytes,5,opt,name=signature_delegation,json=signatureDelegation,proto3,oneof" json:"signature_delegation,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *Signature) Reset() {
	*x = Signature{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Signature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Signature) ProtoMessage() {}

func (x *Signature) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Signature.ProtoReflect.Descriptor instead.
func (*Signature) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{2}
}

func (x *Signature) GetFormat() SignatureFormat {
	if x != nil {
		return x.Format
	}
	return SignatureFormat_SIGNATURE_FORMAT_UNSPECIFIED
}

func (x *Signature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *Signature) GetSignedBy() string {
	if x != nil {
		return x.SignedBy
	}
	return ""
}

func (x *Signature) GetSigningAlgorithmSpec() SigningAlgorithmSpec {
	if x != nil {
		return x.SigningAlgorithmSpec
	}
	return SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_UNSPECIFIED
}

func (x *Signature) GetSignatureDelegation() *SignatureDelegation {
	if x != nil {
		return x.SignatureDelegation
	}
	return nil
}

type SignatureDelegation struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	SessionKey                    []byte                 `protobuf:"bytes,1,opt,name=session_key,json=sessionKey,proto3" json:"session_key,omitempty"`
	SessionKeySpec                SigningKeySpec         `protobuf:"varint,2,opt,name=session_key_spec,json=sessionKeySpec,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeySpec" json:"session_key_spec,omitempty"`
	ValidityPeriodFromInclusive   int64                  `protobuf:"varint,3,opt,name=validity_period_from_inclusive,json=validityPeriodFromInclusive,proto3" json:"validity_period_from_inclusive,omitempty"`
	ValidityPeriodDurationSeconds uint32                 `protobuf:"varint,4,opt,name=validity_period_duration_seconds,json=validityPeriodDurationSeconds,proto3" json:"validity_period_duration_seconds,omitempty"`
	Format                        SignatureFormat        `protobuf:"varint,5,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.SignatureFormat" json:"format,omitempty"`
	Signature                     []byte                 `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature,omitempty"`
	SigningAlgorithmSpec          SigningAlgorithmSpec   `protobuf:"varint,7,opt,name=signing_algorithm_spec,json=signingAlgorithmSpec,proto3,enum=com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec" json:"signing_algorithm_spec,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *SignatureDelegation) Reset() {
	*x = SignatureDelegation{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureDelegation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureDelegation) ProtoMessage() {}

func (x *SignatureDelegation) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureDelegation.ProtoReflect.Descriptor instead.
func (*SignatureDelegation) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{3}
}

func (x *SignatureDelegation) GetSessionKey() []byte {
	if x != nil {
		return x.SessionKey
	}
	return nil
}

func (x *SignatureDelegation) GetSessionKeySpec() SigningKeySpec {
	if x != nil {
		return x.SessionKeySpec
	}
	return SigningKeySpec_SIGNING_KEY_SPEC_UNSPECIFIED
}

func (x *SignatureDelegation) GetValidityPeriodFromInclusive() int64 {
	if x != nil {
		return x.ValidityPeriodFromInclusive
	}
	return 0
}

func (x *SignatureDelegation) GetValidityPeriodDurationSeconds() uint32 {
	if x != nil {
		return x.ValidityPeriodDurationSeconds
	}
	return 0
}

func (x *SignatureDelegation) GetFormat() SignatureFormat {
	if x != nil {
		return x.Format
	}
	return SignatureFormat_SIGNATURE_FORMAT_UNSPECIFIED
}

func (x *SignatureDelegation) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignatureDelegation) GetSigningAlgorithmSpec() SigningAlgorithmSpec {
	if x != nil {
		return x.SigningAlgorithmSpec
	}
	return SigningAlgorithmSpec_SIGNING_ALGORITHM_SPEC_UNSPECIFIED
}

type PublicKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Key:
	//
	//	*PublicKey_SigningPublicKey
	//	*PublicKey_EncryptionPublicKey
	Key           isPublicKey_Key `protobuf_oneof:"key"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKey) Reset() {
	*x = PublicKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKey) ProtoMessage() {}

func (x *PublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKey.ProtoReflect.Descriptor instead.
func (*PublicKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{4}
}

func (x *PublicKey) GetKey() isPublicKey_Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *PublicKey) GetSigningPublicKey() *SigningPublicKey {
	if x != nil {
		if x, ok := x.Key.(*PublicKey_SigningPublicKey); ok {
			return x.SigningPublicKey
		}
	}
	return nil
}

func (x *PublicKey) GetEncryptionPublicKey() *EncryptionPublicKey {
	if x != nil {
		if x, ok := x.Key.(*PublicKey_EncryptionPublicKey); ok {
			return x.EncryptionPublicKey
		}
	}
	return nil
}

type isPublicKey_Key interface {
	isPublicKey_Key()
}

type PublicKey_SigningPublicKey struct {
	SigningPublicKey *SigningPublicKey `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3,oneof"`
}

type PublicKey_EncryptionPublicKey struct {
	EncryptionPublicKey *EncryptionPublicKey `protobuf:"bytes,2,opt,name=encryption_public_key,json=encryptionPublicKey,proto3,oneof"`
}

func (*PublicKey_SigningPublicKey) isPublicKey_Key() {}

func (*PublicKey_EncryptionPublicKey) isPublicKey_Key() {}

type PublicKeyWithName struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PublicKey     *PublicKey             `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKeyWithName) Reset() {
	*x = PublicKeyWithName{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKeyWithName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKeyWithName) ProtoMessage() {}

func (x *PublicKeyWithName) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKeyWithName.ProtoReflect.Descriptor instead.
func (*PublicKeyWithName) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{5}
}

func (x *PublicKeyWithName) GetPublicKey() *PublicKey {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *PublicKeyWithName) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type PrivateKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Key:
	//
	//	*PrivateKey_SigningPrivateKey
	//	*PrivateKey_EncryptionPrivateKey
	Key           isPrivateKey_Key `protobuf_oneof:"key"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrivateKey) Reset() {
	*x = PrivateKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrivateKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrivateKey) ProtoMessage() {}

func (x *PrivateKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrivateKey.ProtoReflect.Descriptor instead.
func (*PrivateKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{6}
}

func (x *PrivateKey) GetKey() isPrivateKey_Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *PrivateKey) GetSigningPrivateKey() *SigningPrivateKey {
	if x != nil {
		if x, ok := x.Key.(*PrivateKey_SigningPrivateKey); ok {
			return x.SigningPrivateKey
		}
	}
	return nil
}

func (x *PrivateKey) GetEncryptionPrivateKey() *EncryptionPrivateKey {
	if x != nil {
		if x, ok := x.Key.(*PrivateKey_EncryptionPrivateKey); ok {
			return x.EncryptionPrivateKey
		}
	}
	return nil
}

type isPrivateKey_Key interface {
	isPrivateKey_Key()
}

type PrivateKey_SigningPrivateKey struct {
	SigningPrivateKey *SigningPrivateKey `protobuf:"bytes,1,opt,name=signing_private_key,json=signingPrivateKey,proto3,oneof"`
}

type PrivateKey_EncryptionPrivateKey struct {
	EncryptionPrivateKey *EncryptionPrivateKey `protobuf:"bytes,2,opt,name=encryption_private_key,json=encryptionPrivateKey,proto3,oneof"`
}

func (*PrivateKey_SigningPrivateKey) isPrivateKey_Key() {}

func (*PrivateKey_EncryptionPrivateKey) isPrivateKey_Key() {}

type SigningPublicKey struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Format    CryptoKeyFormat        `protobuf:"varint,2,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.CryptoKeyFormat" json:"format,omitempty"`
	PublicKey []byte                 `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
	Scheme        SigningKeyScheme  `protobuf:"varint,4,opt,name=scheme,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeyScheme" json:"scheme,omitempty"`
	Usage         []SigningKeyUsage `protobuf:"varint,5,rep,packed,name=usage,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeyUsage" json:"usage,omitempty"`
	KeySpec       SigningKeySpec    `protobuf:"varint,6,opt,name=key_spec,json=keySpec,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeySpec" json:"key_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningPublicKey) Reset() {
	*x = SigningPublicKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningPublicKey) ProtoMessage() {}

func (x *SigningPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningPublicKey.ProtoReflect.Descriptor instead.
func (*SigningPublicKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{7}
}

func (x *SigningPublicKey) GetFormat() CryptoKeyFormat {
	if x != nil {
		return x.Format
	}
	return CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED
}

func (x *SigningPublicKey) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
func (x *SigningPublicKey) GetScheme() SigningKeyScheme {
	if x != nil {
		return x.Scheme
	}
	return SigningKeyScheme_SIGNING_KEY_SCHEME_UNSPECIFIED
}

func (x *SigningPublicKey) GetUsage() []SigningKeyUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *SigningPublicKey) GetKeySpec() SigningKeySpec {
	if x != nil {
		return x.KeySpec
	}
	return SigningKeySpec_SIGNING_KEY_SPEC_UNSPECIFIED
}

type SigningPrivateKey struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Id         string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Format     CryptoKeyFormat        `protobuf:"varint,2,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.CryptoKeyFormat" json:"format,omitempty"`
	PrivateKey []byte                 `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
	Scheme        SigningKeyScheme  `protobuf:"varint,4,opt,name=scheme,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeyScheme" json:"scheme,omitempty"`
	Usage         []SigningKeyUsage `protobuf:"varint,5,rep,packed,name=usage,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeyUsage" json:"usage,omitempty"`
	KeySpec       SigningKeySpec    `protobuf:"varint,6,opt,name=key_spec,json=keySpec,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeySpec" json:"key_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningPrivateKey) Reset() {
	*x = SigningPrivateKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningPrivateKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningPrivateKey) ProtoMessage() {}

func (x *SigningPrivateKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningPrivateKey.ProtoReflect.Descriptor instead.
func (*SigningPrivateKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{8}
}

func (x *SigningPrivateKey) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *SigningPrivateKey) GetFormat() CryptoKeyFormat {
	if x != nil {
		return x.Format
	}
	return CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED
}

func (x *SigningPrivateKey) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
func (x *SigningPrivateKey) GetScheme() SigningKeyScheme {
	if x != nil {
		return x.Scheme
	}
	return SigningKeyScheme_SIGNING_KEY_SCHEME_UNSPECIFIED
}

func (x *SigningPrivateKey) GetUsage() []SigningKeyUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *SigningPrivateKey) GetKeySpec() SigningKeySpec {
	if x != nil {
		return x.KeySpec
	}
	return SigningKeySpec_SIGNING_KEY_SPEC_UNSPECIFIED
}

type SigningKeyPair struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PublicKey     *SigningPublicKey      `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PrivateKey    *SigningPrivateKey     `protobuf:"bytes,2,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningKeyPair) Reset() {
	*x = SigningKeyPair{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningKeyPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningKeyPair) ProtoMessage() {}

func (x *SigningKeyPair) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningKeyPair.ProtoReflect.Descriptor instead.
func (*SigningKeyPair) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{9}
}

func (x *SigningKeyPair) GetPublicKey() *SigningPublicKey {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SigningKeyPair) GetPrivateKey() *SigningPrivateKey {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

type RequiredSigningSpecs struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Algorithms    []SigningAlgorithmSpec `protobuf:"varint,1,rep,packed,name=algorithms,proto3,enum=com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec" json:"algorithms,omitempty"`
	Keys          []SigningKeySpec       `protobuf:"varint,2,rep,packed,name=keys,proto3,enum=com.digitalasset.canton.crypto.v30.SigningKeySpec" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequiredSigningSpecs) Reset() {
	*x = RequiredSigningSpecs{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequiredSigningSpecs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequiredSigningSpecs) ProtoMessage() {}

func (x *RequiredSigningSpecs) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequiredSigningSpecs.ProtoReflect.Descriptor instead.
func (*RequiredSigningSpecs) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{10}
}

func (x *RequiredSigningSpecs) GetAlgorithms() []SigningAlgorithmSpec {
	if x != nil {
		return x.Algorithms
	}
	return nil
}

func (x *RequiredSigningSpecs) GetKeys() []SigningKeySpec {
	if x != nil {
		return x.Keys
	}
	return nil
}

type EncryptionPublicKey struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Format    CryptoKeyFormat        `protobuf:"varint,2,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.CryptoKeyFormat" json:"format,omitempty"`
	PublicKey []byte                 `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
	Scheme        EncryptionKeyScheme `protobuf:"varint,4,opt,name=scheme,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionKeyScheme" json:"scheme,omitempty"`
	KeySpec       EncryptionKeySpec   `protobuf:"varint,5,opt,name=key_spec,json=keySpec,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionKeySpec" json:"key_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptionPublicKey) Reset() {
	*x = EncryptionPublicKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionPublicKey) ProtoMessage() {}

func (x *EncryptionPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionPublicKey.ProtoReflect.Descriptor instead.
func (*EncryptionPublicKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{11}
}

func (x *EncryptionPublicKey) GetFormat() CryptoKeyFormat {
	if x != nil {
		return x.Format
	}
	return CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED
}

func (x *EncryptionPublicKey) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
func (x *EncryptionPublicKey) GetScheme() EncryptionKeyScheme {
	if x != nil {
		return x.Scheme
	}
	return EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_UNSPECIFIED
}

func (x *EncryptionPublicKey) GetKeySpec() EncryptionKeySpec {
	if x != nil {
		return x.KeySpec
	}
	return EncryptionKeySpec_ENCRYPTION_KEY_SPEC_UNSPECIFIED
}

type EncryptionPrivateKey struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Id         string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Format     CryptoKeyFormat        `protobuf:"varint,2,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.CryptoKeyFormat" json:"format,omitempty"`
	PrivateKey []byte                 `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
	Scheme        EncryptionKeyScheme `protobuf:"varint,4,opt,name=scheme,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionKeyScheme" json:"scheme,omitempty"`
	KeySpec       EncryptionKeySpec   `protobuf:"varint,5,opt,name=key_spec,json=keySpec,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionKeySpec" json:"key_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptionPrivateKey) Reset() {
	*x = EncryptionPrivateKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionPrivateKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionPrivateKey) ProtoMessage() {}

func (x *EncryptionPrivateKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionPrivateKey.ProtoReflect.Descriptor instead.
func (*EncryptionPrivateKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{12}
}

func (x *EncryptionPrivateKey) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *EncryptionPrivateKey) GetFormat() CryptoKeyFormat {
	if x != nil {
		return x.Format
	}
	return CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED
}

func (x *EncryptionPrivateKey) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

// Deprecated: Marked as deprecated in com/digitalasset/canton/crypto/v30/crypto.proto.
func (x *EncryptionPrivateKey) GetScheme() EncryptionKeyScheme {
	if x != nil {
		return x.Scheme
	}
	return EncryptionKeyScheme_ENCRYPTION_KEY_SCHEME_UNSPECIFIED
}

func (x *EncryptionPrivateKey) GetKeySpec() EncryptionKeySpec {
	if x != nil {
		return x.KeySpec
	}
	return EncryptionKeySpec_ENCRYPTION_KEY_SPEC_UNSPECIFIED
}

type EncryptionKeyPair struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PublicKey     *EncryptionPublicKey   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PrivateKey    *EncryptionPrivateKey  `protobuf:"bytes,2,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EncryptionKeyPair) Reset() {
	*x = EncryptionKeyPair{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptionKeyPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptionKeyPair) ProtoMessage() {}

func (x *EncryptionKeyPair) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptionKeyPair.ProtoReflect.Descriptor instead.
func (*EncryptionKeyPair) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{13}
}

func (x *EncryptionKeyPair) GetPublicKey() *EncryptionPublicKey {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *EncryptionKeyPair) GetPrivateKey() *EncryptionPrivateKey {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

type RequiredEncryptionSpecs struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Algorithms    []EncryptionAlgorithmSpec `protobuf:"varint,1,rep,packed,name=algorithms,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec" json:"algorithms,omitempty"`
	Keys          []EncryptionKeySpec       `protobuf:"varint,2,rep,packed,name=keys,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionKeySpec" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequiredEncryptionSpecs) Reset() {
	*x = RequiredEncryptionSpecs{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequiredEncryptionSpecs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequiredEncryptionSpecs) ProtoMessage() {}

func (x *RequiredEncryptionSpecs) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequiredEncryptionSpecs.ProtoReflect.Descriptor instead.
func (*RequiredEncryptionSpecs) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{14}
}

func (x *RequiredEncryptionSpecs) GetAlgorithms() []EncryptionAlgorithmSpec {
	if x != nil {
		return x.Algorithms
	}
	return nil
}

func (x *RequiredEncryptionSpecs) GetKeys() []EncryptionKeySpec {
	if x != nil {
		return x.Keys
	}
	return nil
}

type CryptoKeyPair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Pair:
	//
	//	*CryptoKeyPair_SigningKeyPair
	//	*CryptoKeyPair_EncryptionKeyPair
	Pair          isCryptoKeyPair_Pair `protobuf_oneof:"pair"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CryptoKeyPair) Reset() {
	*x = CryptoKeyPair{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CryptoKeyPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CryptoKeyPair) ProtoMessage() {}

func (x *CryptoKeyPair) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CryptoKeyPair.ProtoReflect.Descriptor instead.
func (*CryptoKeyPair) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{15}
}

func (x *CryptoKeyPair) GetPair() isCryptoKeyPair_Pair {
	if x != nil {
		return x.Pair
	}
	return nil
}

func (x *CryptoKeyPair) GetSigningKeyPair() *SigningKeyPair {
	if x != nil {
		if x, ok := x.Pair.(*CryptoKeyPair_SigningKeyPair); ok {
			return x.SigningKeyPair
		}
	}
	return nil
}

func (x *CryptoKeyPair) GetEncryptionKeyPair() *EncryptionKeyPair {
	if x != nil {
		if x, ok := x.Pair.(*CryptoKeyPair_EncryptionKeyPair); ok {
			return x.EncryptionKeyPair
		}
	}
	return nil
}

type isCryptoKeyPair_Pair interface {
	isCryptoKeyPair_Pair()
}

type CryptoKeyPair_SigningKeyPair struct {
	SigningKeyPair *SigningKeyPair `protobuf:"bytes,1,opt,name=signing_key_pair,json=signingKeyPair,proto3,oneof"`
}

type CryptoKeyPair_EncryptionKeyPair struct {
	EncryptionKeyPair *EncryptionKeyPair `protobuf:"bytes,2,opt,name=encryption_key_pair,json=encryptionKeyPair,proto3,oneof"`
}

func (*CryptoKeyPair_SigningKeyPair) isCryptoKeyPair_Pair() {}

func (*CryptoKeyPair_EncryptionKeyPair) isCryptoKeyPair_Pair() {}

type SymmetricKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Format        CryptoKeyFormat        `protobuf:"varint,1,opt,name=format,proto3,enum=com.digitalasset.canton.crypto.v30.CryptoKeyFormat" json:"format,omitempty"`
	Key           []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Scheme        SymmetricKeyScheme     `protobuf:"varint,3,opt,name=scheme,proto3,enum=com.digitalasset.canton.crypto.v30.SymmetricKeyScheme" json:"scheme,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SymmetricKey) Reset() {
	*x = SymmetricKey{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SymmetricKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SymmetricKey) ProtoMessage() {}

func (x *SymmetricKey) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SymmetricKey.ProtoReflect.Descriptor instead.
func (*SymmetricKey) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{16}
}

func (x *SymmetricKey) GetFormat() CryptoKeyFormat {
	if x != nil {
		return x.Format
	}
	return CryptoKeyFormat_CRYPTO_KEY_FORMAT_UNSPECIFIED
}

func (x *SymmetricKey) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *SymmetricKey) GetScheme() SymmetricKeyScheme {
	if x != nil {
		return x.Scheme
	}
	return SymmetricKeyScheme_SYMMETRIC_KEY_SCHEME_UNSPECIFIED
}

type PasswordBasedEncrypted struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Ciphertext         []byte                 `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	SymmetricKeyScheme SymmetricKeyScheme     `protobuf:"varint,2,opt,name=symmetric_key_scheme,json=symmetricKeyScheme,proto3,enum=com.digitalasset.canton.crypto.v30.SymmetricKeyScheme" json:"symmetric_key_scheme,omitempty"`
	PbkdfScheme        PbkdfScheme            `protobuf:"varint,3,opt,name=pbkdf_scheme,json=pbkdfScheme,proto3,enum=com.digitalasset.canton.crypto.v30.PbkdfScheme" json:"pbkdf_scheme,omitempty"`
	Salt               []byte                 `protobuf:"bytes,4,opt,name=salt,proto3" json:"salt,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PasswordBasedEncrypted) Reset() {
	*x = PasswordBasedEncrypted{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PasswordBasedEncrypted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PasswordBasedEncrypted) ProtoMessage() {}

func (x *PasswordBasedEncrypted) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PasswordBasedEncrypted.ProtoReflect.Descriptor instead.
func (*PasswordBasedEncrypted) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{17}
}

func (x *PasswordBasedEncrypted) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *PasswordBasedEncrypted) GetSymmetricKeyScheme() SymmetricKeyScheme {
	if x != nil {
		return x.SymmetricKeyScheme
	}
	return SymmetricKeyScheme_SYMMETRIC_KEY_SCHEME_UNSPECIFIED
}

func (x *PasswordBasedEncrypted) GetPbkdfScheme() PbkdfScheme {
	if x != nil {
		return x.PbkdfScheme
	}
	return PbkdfScheme_PBKDF_SCHEME_UNSPECIFIED
}

func (x *PasswordBasedEncrypted) GetSalt() []byte {
	if x != nil {
		return x.Salt
	}
	return nil
}

type AsymmetricEncrypted struct {
	state                   protoimpl.MessageState  `protogen:"open.v1"`
	Ciphertext              []byte                  `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	EncryptionAlgorithmSpec EncryptionAlgorithmSpec `protobuf:"varint,2,opt,name=encryption_algorithm_spec,json=encryptionAlgorithmSpec,proto3,enum=com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec" json:"encryption_algorithm_spec,omitempty"`
	Fingerprint             string                  `protobuf:"bytes,3,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *AsymmetricEncrypted) Reset() {
	*x = AsymmetricEncrypted{}
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AsymmetricEncrypted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AsymmetricEncrypted) ProtoMessage() {}

func (x *AsymmetricEncrypted) ProtoReflect() protoreflect.Message {
	mi := &file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AsymmetricEncrypted.ProtoReflect.Descriptor instead.
func (*AsymmetricEncrypted) Descriptor() ([]byte, []int) {
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP(), []int{18}
}

func (x *AsymmetricEncrypted) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *AsymmetricEncrypted) GetEncryptionAlgorithmSpec() EncryptionAlgorithmSpec {
	if x != nil {
		return x.EncryptionAlgorithmSpec
	}
	return EncryptionAlgorithmSpec_ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED
}

func (x *AsymmetricEncrypted) GetFingerprint() string {
	if x != nil {
		return x.Fingerprint
	}
	return ""
}

var File_com_digitalasset_canton_crypto_v30_crypto_proto protoreflect.FileDescriptor

const file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDesc = "" +
	"\n" +
	"/com/digitalasset/canton/crypto/v30/crypto.proto\x12\"com.digitalasset.canton.crypto.v30\"k\n" +
	"\x04Hmac\x12O\n" +
	"\talgorithm\x18\x01 \x01(\x0e21.com.digitalasset.canton.crypto.v30.HmacAlgorithmR\talgorithm\x12\x12\n" +
	"\x04hmac\x18\x02 \x01(\fR\x04hmac\"p\n" +
	"\x04Salt\x12G\n" +
	"\x04hmac\x18\x01 \x01(\x0e21.com.digitalasset.canton.crypto.v30.HmacAlgorithmH\x00R\x04hmac\x12\x12\n" +
	"\x04salt\x18\x02 \x01(\fR\x04saltB\v\n" +
	"\talgorithm\"\x8d\x03\n" +
	"\tSignature\x12K\n" +
	"\x06format\x18\x01 \x01(\x0e23.com.digitalasset.canton.crypto.v30.SignatureFormatR\x06format\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\x12\x1b\n" +
	"\tsigned_by\x18\x03 \x01(\tR\bsignedBy\x12n\n" +
	"\x16signing_algorithm_spec\x18\x04 \x01(\x0e28.com.digitalasset.canton.crypto.v30.SigningAlgorithmSpecR\x14signingAlgorithmSpec\x12o\n" +
	"\x14signature_delegation\x18\x05 \x01(\v27.com.digitalasset.canton.crypto.v30.SignatureDelegationH\x00R\x13signatureDelegation\x88\x01\x01B\x17\n" +
	"\x15_signature_delegation\"\xfd\x03\n" +
	"\x13SignatureDelegation\x12\x1f\n" +
	"\vsession_key\x18\x01 \x01(\fR\n" +
	"sessionKey\x12\\\n" +
	"\x10session_key_spec\x18\x02 \x01(\x0e22.com.digitalasset.canton.crypto.v30.SigningKeySpecR\x0esessionKeySpec\x12C\n" +
	"\x1evalidity_period_from_inclusive\x18\x03 \x01(\x03R\x1bvalidityPeriodFromInclusive\x12G\n" +
	" validity_period_duration_seconds\x18\x04 \x01(\rR\x1dvalidityPeriodDurationSeconds\x12K\n" +
	"\x06format\x18\x05 \x01(\x0e23.com.digitalasset.canton.crypto.v30.SignatureFormatR\x06format\x12\x1c\n" +
	"\tsignature\x18\x06 \x01(\fR\tsignature\x12n\n" +
	"\x16signing_algorithm_spec\x18\a \x01(\x0e28.com.digitalasset.canton.crypto.v30.SigningAlgorithmSpecR\x14signingAlgorithmSpec\"\xe7\x01\n" +
	"\tPublicKey\x12d\n" +
	"\x12signing_public_key\x18\x01 \x01(\v24.com.digitalasset.canton.crypto.v30.SigningPublicKeyH\x00R\x10signingPublicKey\x12m\n" +
	"\x15encryption_public_key\x18\x02 \x01(\v27.com.digitalasset.canton.crypto.v30.EncryptionPublicKeyH\x00R\x13encryptionPublicKeyB\x05\n" +
	"\x03key\"u\n" +
	"\x11PublicKeyWithName\x12L\n" +
	"\n" +
	"public_key\x18\x01 \x01(\v2-.com.digitalasset.canton.crypto.v30.PublicKeyR\tpublicKey\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\xee\x01\n" +
	"\n" +
	"PrivateKey\x12g\n" +
	"\x13signing_private_key\x18\x01 \x01(\v25.com.digitalasset.canton.crypto.v30.SigningPrivateKeyH\x00R\x11signingPrivateKey\x12p\n" +
	"\x16encryption_private_key\x18\x02 \x01(\v28.com.digitalasset.canton.crypto.v30.EncryptionPrivateKeyH\x00R\x14encryptionPrivateKeyB\x05\n" +
	"\x03key\"\xf0\x02\n" +
	"\x10SigningPublicKey\x12K\n" +
	"\x06format\x18\x02 \x01(\x0e23.com.digitalasset.canton.crypto.v30.CryptoKeyFormatR\x06format\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12P\n" +
	"\x06scheme\x18\x04 \x01(\x0e24.com.digitalasset.canton.crypto.v30.SigningKeySchemeB\x02\x18\x01R\x06scheme\x12I\n" +
	"\x05usage\x18\x05 \x03(\x0e23.com.digitalasset.canton.crypto.v30.SigningKeyUsageR\x05usage\x12M\n" +
	"\bkey_spec\x18\x06 \x01(\x0e22.com.digitalasset.canton.crypto.v30.SigningKeySpecR\akeySpecJ\x04\b\x01\x10\x02\"\xfd\x02\n" +
	"\x11SigningPrivateKey\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12K\n" +
	"\x06format\x18\x02 \x01(\x0e23.com.digitalasset.canton.crypto.v30.CryptoKeyFormatR\x06format\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\fR\n" +
	"privateKey\x12P\n" +
	"\x06scheme\x18\x04 \x01(\x0e24.com.digitalasset.canton.crypto.v30.SigningKeySchemeB\x02\x18\x01R\x06scheme\x12I\n" +
	"\x05usage\x18\x05 \x03(\x0e23.com.digitalasset.canton.crypto.v30.SigningKeyUsageR\x05usage\x12M\n" +
	"\bkey_spec\x18\x06 \x01(\x0e22.com.digitalasset.canton.crypto.v30.SigningKeySpecR\akeySpec\"\xbd\x01\n" +
	"\x0eSigningKeyPair\x12S\n" +
	"\n" +
	"public_key\x18\x01 \x01(\v24.com.digitalasset.canton.crypto.v30.SigningPublicKeyR\tpublicKey\x12V\n" +
	"\vprivate_key\x18\x02 \x01(\v25.com.digitalasset.canton.crypto.v30.SigningPrivateKeyR\n" +
	"privateKey\"\xb8\x01\n" +
	"\x14RequiredSigningSpecs\x12X\n" +
	"\n" +
	"algorithms\x18\x01 \x03(\x0e28.com.digitalasset.canton.crypto.v30.SigningAlgorithmSpecR\n" +
	"algorithms\x12F\n" +
	"\x04keys\x18\x02 \x03(\x0e22.com.digitalasset.canton.crypto.v30.SigningKeySpecR\x04keys\"\xae\x02\n" +
	"\x13EncryptionPublicKey\x12K\n" +
	"\x06format\x18\x02 \x01(\x0e23.com.digitalasset.canton.crypto.v30.CryptoKeyFormatR\x06format\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12S\n" +
	"\x06scheme\x18\x04 \x01(\x0e27.com.digitalasset.canton.crypto.v30.EncryptionKeySchemeB\x02\x18\x01R\x06scheme\x12P\n" +
	"\bkey_spec\x18\x05 \x01(\x0e25.com.digitalasset.canton.crypto.v30.EncryptionKeySpecR\akeySpecJ\x04\b\x01\x10\x02\"\xbb\x02\n" +
	"\x14EncryptionPrivateKey\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12K\n" +
	"\x06format\x18\x02 \x01(\x0e23.com.digitalasset.canton.crypto.v30.CryptoKeyFormatR\x06format\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\fR\n" +
	"privateKey\x12S\n" +
	"\x06scheme\x18\x04 \x01(\x0e27.com.digitalasset.canton.crypto.v30.EncryptionKeySchemeB\x02\x18\x01R\x06scheme\x12P\n" +
	"\bkey_spec\x18\x05 \x01(\x0e25.com.digitalasset.canton.crypto.v30.EncryptionKeySpecR\akeySpec\"\xc6\x01\n" +
	"\x11EncryptionKeyPair\x12V\n" +
	"\n" +
	"public_key\x18\x01 \x01(\v27.com.digitalasset.canton.crypto.v30.EncryptionPublicKeyR\tpublicKey\x12Y\n" +
	"\vprivate_key\x18\x02 \x01(\v28.com.digitalasset.canton.crypto.v30.EncryptionPrivateKeyR\n" +
	"privateKey\"\xc1\x01\n" +
	"\x17RequiredEncryptionSpecs\x12[\n" +
	"\n" +
	"algorithms\x18\x01 \x03(\x0e2;.com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpecR\n" +
	"algorithms\x12I\n" +
	"\x04keys\x18\x02 \x03(\x0e25.com.digitalasset.canton.crypto.v30.EncryptionKeySpecR\x04keys\"\xe0\x01\n" +
	"\rCryptoKeyPair\x12^\n" +
	"\x10signing_key_pair\x18\x01 \x01(\v22.com.digitalasset.canton.crypto.v30.SigningKeyPairH\x00R\x0esigningKeyPair\x12g\n" +
	"\x13encryption_key_pair\x18\x02 \x01(\v25.com.digitalasset.canton.crypto.v30.EncryptionKeyPairH\x00R\x11encryptionKeyPairB\x06\n" +
	"\x04pair\"\xbd\x01\n" +
	"\fSymmetricKey\x12K\n" +
	"\x06format\x18\x01 \x01(\x0e23.com.digitalasset.canton.crypto.v30.CryptoKeyFormatR\x06format\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12N\n" +
	"\x06scheme\x18\x03 \x01(\x0e26.com.digitalasset.canton.crypto.v30.SymmetricKeySchemeR\x06scheme\"\x8a\x02\n" +
	"\x16PasswordBasedEncrypted\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12h\n" +
	"\x14symmetric_key_scheme\x18\x02 \x01(\x0e26.com.digitalasset.canton.crypto.v30.SymmetricKeySchemeR\x12symmetricKeyScheme\x12R\n" +
	"\fpbkdf_scheme\x18\x03 \x01(\x0e2/.com.digitalasset.canton.crypto.v30.PbkdfSchemeR\vpbkdfScheme\x12\x12\n" +
	"\x04salt\x18\x04 \x01(\fR\x04salt\"\xd0\x01\n" +
	"\x13AsymmetricEncrypted\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12w\n" +
	"\x19encryption_algorithm_spec\x18\x02 \x01(\x0e2;.com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpecR\x17encryptionAlgorithmSpec\x12 \n" +
	"\vfingerprint\x18\x03 \x01(\tR\vfingerprint*J\n" +
	"\rHashAlgorithm\x12\x1e\n" +
	"\x1aHASH_ALGORITHM_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15HASH_ALGORITHM_SHA256\x10\x01*O\n" +
	"\rHmacAlgorithm\x12\x1e\n" +
	"\x1aHMAC_ALGORITHM_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aHMAC_ALGORITHM_HMAC_SHA256\x10\x01*\xa4\x01\n" +
	"\x0fSignatureFormat\x12 \n" +
	"\x1cSIGNATURE_FORMAT_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14SIGNATURE_FORMAT_RAW\x10\x01\x12\x18\n" +
	"\x14SIGNATURE_FORMAT_DER\x10\x02\x12\x1b\n" +
	"\x17SIGNATURE_FORMAT_CONCAT\x10\x03\x12\x1e\n" +
	"\x19SIGNATURE_FORMAT_SYMBOLIC\x10\x90N*{\n" +
	"\x11EncryptionKeySpec\x12#\n" +
	"\x1fENCRYPTION_KEY_SPEC_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bENCRYPTION_KEY_SPEC_EC_P256\x10\x01\x12 \n" +
	"\x1cENCRYPTION_KEY_SPEC_RSA_2048\x10\x02*\xb5\x01\n" +
	"\x0eSigningKeySpec\x12 \n" +
	"\x1cSIGNING_KEY_SPEC_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eSIGNING_KEY_SPEC_EC_CURVE25519\x10\x01\x12\x1c\n" +
	"\x18SIGNING_KEY_SPEC_EC_P256\x10\x02\x12\x1c\n" +
	"\x18SIGNING_KEY_SPEC_EC_P384\x10\x03\x12!\n" +
	"\x1dSIGNING_KEY_SPEC_EC_SECP256K1\x10\x04*^\n" +
	"\n" +
	"KeyPurpose\x12\x1b\n" +
	"\x17KEY_PURPOSE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13KEY_PURPOSE_SIGNING\x10\x01\x12\x1a\n" +
	"\x16KEY_PURPOSE_ENCRYPTION\x10\x02*\xfe\x01\n" +
	"\x0fSigningKeyUsage\x12!\n" +
	"\x1dSIGNING_KEY_USAGE_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bSIGNING_KEY_USAGE_NAMESPACE\x10\x01\x12-\n" +
	"%SIGNING_KEY_USAGE_IDENTITY_DELEGATION\x10\x02\x1a\x02\b\x01\x12.\n" +
	"*SIGNING_KEY_USAGE_SEQUENCER_AUTHENTICATION\x10\x03\x12\x1e\n" +
	"\x1aSIGNING_KEY_USAGE_PROTOCOL\x10\x04\x12(\n" +
	"$SIGNING_KEY_USAGE_PROOF_OF_OWNERSHIP\x10\x05*\xb8\x01\n" +
	"\x14SigningAlgorithmSpec\x12&\n" +
	"\"SIGNING_ALGORITHM_SPEC_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eSIGNING_ALGORITHM_SPEC_ED25519\x10\x01\x12)\n" +
	"%SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256\x10\x02\x12)\n" +
	"%SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384\x10\x03*\x9e\x01\n" +
	"\x10SigningKeyScheme\x12\"\n" +
	"\x1eSIGNING_KEY_SCHEME_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aSIGNING_KEY_SCHEME_ED25519\x10\x01\x12\"\n" +
	"\x1eSIGNING_KEY_SCHEME_EC_DSA_P256\x10\x02\x12\"\n" +
	"\x1eSIGNING_KEY_SCHEME_EC_DSA_P384\x10\x03*\xf3\x01\n" +
	"\x17EncryptionAlgorithmSpec\x12)\n" +
	"%ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED\x10\x00\x12>\n" +
	":ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128GCM\x10\x01\x12>\n" +
	":ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128CBC\x10\x02\x12-\n" +
	")ENCRYPTION_ALGORITHM_SPEC_RSA_OAEP_SHA256\x10\x03*\xe8\x01\n" +
	"\x13EncryptionKeyScheme\x12%\n" +
	"!ENCRYPTION_KEY_SCHEME_UNSPECIFIED\x10\x00\x12?\n" +
	";ENCRYPTION_KEY_SCHEME_ECIES_P256_HKDF_HMAC_SHA256_AES128GCM\x10\x01\x12:\n" +
	"6ENCRYPTION_KEY_SCHEME_ECIES_P256_HMAC_SHA256A_ES128CBC\x10\x02\x12-\n" +
	")ENCRYPTION_KEY_SCHEME_RSA2048_OAEP_SHA256\x10\x03*^\n" +
	"\x12SymmetricKeyScheme\x12$\n" +
	" SYMMETRIC_KEY_SCHEME_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eSYMMETRIC_KEY_SCHEME_AES128GCM\x10\x01*\xfb\x01\n" +
	"\x0fCryptoKeyFormat\x12!\n" +
	"\x1dCRYPTO_KEY_FORMAT_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15CRYPTO_KEY_FORMAT_DER\x10\x02\x12\x19\n" +
	"\x15CRYPTO_KEY_FORMAT_RAW\x10\x03\x126\n" +
	"2CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO\x10\x04\x120\n" +
	",CRYPTO_KEY_FORMAT_DER_PKCS8_PRIVATE_KEY_INFO\x10\x05\x12\x1f\n" +
	"\x1aCRYPTO_KEY_FORMAT_SYMBOLIC\x10\x90N\"\x04\b\x01\x10\x01*L\n" +
	"\vPbkdfScheme\x12\x1c\n" +
	"\x18PBKDF_SCHEME_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bPBKDF_SCHEME_ARGON2ID_MODE1\x10\x01BSZQgithub.com/digital-asset/dazl-client/v8/go/api/com/digitalasset/canton/crypto/v30b\x06proto3"

var (
	file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescOnce sync.Once
	file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescData []byte
)

func file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescGZIP() []byte {
	file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescOnce.Do(func() {
		file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDesc), len(file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDesc)))
	})
	return file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDescData
}

var file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes = make([]protoimpl.EnumInfo, 14)
var file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_com_digitalasset_canton_crypto_v30_crypto_proto_goTypes = []any{
	(HashAlgorithm)(0),              // 0: com.digitalasset.canton.crypto.v30.HashAlgorithm
	(HmacAlgorithm)(0),              // 1: com.digitalasset.canton.crypto.v30.HmacAlgorithm
	(SignatureFormat)(0),            // 2: com.digitalasset.canton.crypto.v30.SignatureFormat
	(EncryptionKeySpec)(0),          // 3: com.digitalasset.canton.crypto.v30.EncryptionKeySpec
	(SigningKeySpec)(0),             // 4: com.digitalasset.canton.crypto.v30.SigningKeySpec
	(KeyPurpose)(0),                 // 5: com.digitalasset.canton.crypto.v30.KeyPurpose
	(SigningKeyUsage)(0),            // 6: com.digitalasset.canton.crypto.v30.SigningKeyUsage
	(SigningAlgorithmSpec)(0),       // 7: com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec
	(SigningKeyScheme)(0),           // 8: com.digitalasset.canton.crypto.v30.SigningKeyScheme
	(EncryptionAlgorithmSpec)(0),    // 9: com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec
	(EncryptionKeyScheme)(0),        // 10: com.digitalasset.canton.crypto.v30.EncryptionKeyScheme
	(SymmetricKeyScheme)(0),         // 11: com.digitalasset.canton.crypto.v30.SymmetricKeyScheme
	(CryptoKeyFormat)(0),            // 12: com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	(PbkdfScheme)(0),                // 13: com.digitalasset.canton.crypto.v30.PbkdfScheme
	(*Hmac)(nil),                    // 14: com.digitalasset.canton.crypto.v30.Hmac
	(*Salt)(nil),                    // 15: com.digitalasset.canton.crypto.v30.Salt
	(*Signature)(nil),               // 16: com.digitalasset.canton.crypto.v30.Signature
	(*SignatureDelegation)(nil),     // 17: com.digitalasset.canton.crypto.v30.SignatureDelegation
	(*PublicKey)(nil),               // 18: com.digitalasset.canton.crypto.v30.PublicKey
	(*PublicKeyWithName)(nil),       // 19: com.digitalasset.canton.crypto.v30.PublicKeyWithName
	(*PrivateKey)(nil),              // 20: com.digitalasset.canton.crypto.v30.PrivateKey
	(*SigningPublicKey)(nil),        // 21: com.digitalasset.canton.crypto.v30.SigningPublicKey
	(*SigningPrivateKey)(nil),       // 22: com.digitalasset.canton.crypto.v30.SigningPrivateKey
	(*SigningKeyPair)(nil),          // 23: com.digitalasset.canton.crypto.v30.SigningKeyPair
	(*RequiredSigningSpecs)(nil),    // 24: com.digitalasset.canton.crypto.v30.RequiredSigningSpecs
	(*EncryptionPublicKey)(nil),     // 25: com.digitalasset.canton.crypto.v30.EncryptionPublicKey
	(*EncryptionPrivateKey)(nil),    // 26: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey
	(*EncryptionKeyPair)(nil),       // 27: com.digitalasset.canton.crypto.v30.EncryptionKeyPair
	(*RequiredEncryptionSpecs)(nil), // 28: com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs
	(*CryptoKeyPair)(nil),           // 29: com.digitalasset.canton.crypto.v30.CryptoKeyPair
	(*SymmetricKey)(nil),            // 30: com.digitalasset.canton.crypto.v30.SymmetricKey
	(*PasswordBasedEncrypted)(nil),  // 31: com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted
	(*AsymmetricEncrypted)(nil),     // 32: com.digitalasset.canton.crypto.v30.AsymmetricEncrypted
}
var file_com_digitalasset_canton_crypto_v30_crypto_proto_depIdxs = []int32{
	1,  // 0: com.digitalasset.canton.crypto.v30.Hmac.algorithm:type_name -> com.digitalasset.canton.crypto.v30.HmacAlgorithm
	1,  // 1: com.digitalasset.canton.crypto.v30.Salt.hmac:type_name -> com.digitalasset.canton.crypto.v30.HmacAlgorithm
	2,  // 2: com.digitalasset.canton.crypto.v30.Signature.format:type_name -> com.digitalasset.canton.crypto.v30.SignatureFormat
	7,  // 3: com.digitalasset.canton.crypto.v30.Signature.signing_algorithm_spec:type_name -> com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec
	17, // 4: com.digitalasset.canton.crypto.v30.Signature.signature_delegation:type_name -> com.digitalasset.canton.crypto.v30.SignatureDelegation
	4,  // 5: com.digitalasset.canton.crypto.v30.SignatureDelegation.session_key_spec:type_name -> com.digitalasset.canton.crypto.v30.SigningKeySpec
	2,  // 6: com.digitalasset.canton.crypto.v30.SignatureDelegation.format:type_name -> com.digitalasset.canton.crypto.v30.SignatureFormat
	7,  // 7: com.digitalasset.canton.crypto.v30.SignatureDelegation.signing_algorithm_spec:type_name -> com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec
	21, // 8: com.digitalasset.canton.crypto.v30.PublicKey.signing_public_key:type_name -> com.digitalasset.canton.crypto.v30.SigningPublicKey
	25, // 9: com.digitalasset.canton.crypto.v30.PublicKey.encryption_public_key:type_name -> com.digitalasset.canton.crypto.v30.EncryptionPublicKey
	18, // 10: com.digitalasset.canton.crypto.v30.PublicKeyWithName.public_key:type_name -> com.digitalasset.canton.crypto.v30.PublicKey
	22, // 11: com.digitalasset.canton.crypto.v30.PrivateKey.signing_private_key:type_name -> com.digitalasset.canton.crypto.v30.SigningPrivateKey
	26, // 12: com.digitalasset.canton.crypto.v30.PrivateKey.encryption_private_key:type_name -> com.digitalasset.canton.crypto.v30.EncryptionPrivateKey
	12, // 13: com.digitalasset.canton.crypto.v30.SigningPublicKey.format:type_name -> com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	8,  // 14: com.digitalasset.canton.crypto.v30.SigningPublicKey.scheme:type_name -> com.digitalasset.canton.crypto.v30.SigningKeyScheme
	6,  // 15: com.digitalasset.canton.crypto.v30.SigningPublicKey.usage:type_name -> com.digitalasset.canton.crypto.v30.SigningKeyUsage
	4,  // 16: com.digitalasset.canton.crypto.v30.SigningPublicKey.key_spec:type_name -> com.digitalasset.canton.crypto.v30.SigningKeySpec
	12, // 17: com.digitalasset.canton.crypto.v30.SigningPrivateKey.format:type_name -> com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	8,  // 18: com.digitalasset.canton.crypto.v30.SigningPrivateKey.scheme:type_name -> com.digitalasset.canton.crypto.v30.SigningKeyScheme
	6,  // 19: com.digitalasset.canton.crypto.v30.SigningPrivateKey.usage:type_name -> com.digitalasset.canton.crypto.v30.SigningKeyUsage
	4,  // 20: com.digitalasset.canton.crypto.v30.SigningPrivateKey.key_spec:type_name -> com.digitalasset.canton.crypto.v30.SigningKeySpec
	21, // 21: com.digitalasset.canton.crypto.v30.SigningKeyPair.public_key:type_name -> com.digitalasset.canton.crypto.v30.SigningPublicKey
	22, // 22: com.digitalasset.canton.crypto.v30.SigningKeyPair.private_key:type_name -> com.digitalasset.canton.crypto.v30.SigningPrivateKey
	7,  // 23: com.digitalasset.canton.crypto.v30.RequiredSigningSpecs.algorithms:type_name -> com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec
	4,  // 24: com.digitalasset.canton.crypto.v30.RequiredSigningSpecs.keys:type_name -> com.digitalasset.canton.crypto.v30.SigningKeySpec
	12, // 25: com.digitalasset.canton.crypto.v30.EncryptionPublicKey.format:type_name -> com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	10, // 26: com.digitalasset.canton.crypto.v30.EncryptionPublicKey.scheme:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeyScheme
	3,  // 27: com.digitalasset.canton.crypto.v30.EncryptionPublicKey.key_spec:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeySpec
	12, // 28: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey.format:type_name -> com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	10, // 29: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey.scheme:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeyScheme
	3,  // 30: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey.key_spec:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeySpec
	25, // 31: com.digitalasset.canton.crypto.v30.EncryptionKeyPair.public_key:type_name -> com.digitalasset.canton.crypto.v30.EncryptionPublicKey
	26, // 32: com.digitalasset.canton.crypto.v30.EncryptionKeyPair.private_key:type_name -> com.digitalasset.canton.crypto.v30.EncryptionPrivateKey
	9,  // 33: com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs.algorithms:type_name -> com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec
	3,  // 34: com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs.keys:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeySpec
	23, // 35: com.digitalasset.canton.crypto.v30.CryptoKeyPair.signing_key_pair:type_name -> com.digitalasset.canton.crypto.v30.SigningKeyPair
	27, // 36: com.digitalasset.canton.crypto.v30.CryptoKeyPair.encryption_key_pair:type_name -> com.digitalasset.canton.crypto.v30.EncryptionKeyPair
	12, // 37: com.digitalasset.canton.crypto.v30.SymmetricKey.format:type_name -> com.digitalasset.canton.crypto.v30.CryptoKeyFormat
	11, // 38: com.digitalasset.canton.crypto.v30.SymmetricKey.scheme:type_name -> com.digitalasset.canton.crypto.v30.SymmetricKeyScheme
	11, // 39: com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted.symmetric_key_scheme:type_name -> com.digitalasset.canton.crypto.v30.SymmetricKeyScheme
	13, // 40: com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted.pbkdf_scheme:type_name -> com.digitalasset.canton.crypto.v30.PbkdfScheme
	9,  // 41: com.digitalasset.canton.crypto.v30.AsymmetricEncrypted.encryption_algorithm_spec:type_name -> com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec
	42, // [42:42] is the sub-list for method output_type
	42, // [42:42] is the sub-list for method input_type
	42, // [42:42] is the sub-list for extension type_name
	42, // [42:42] is the sub-list for extension extendee
	0,  // [0:42] is the sub-list for field type_name
}

func init() { file_com_digitalasset_canton_crypto_v30_crypto_proto_init() }
func file_com_digitalasset_canton_crypto_v30_crypto_proto_init() {
	if File_com_digitalasset_canton_crypto_v30_crypto_proto != nil {
		return
	}
	file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[1].OneofWrappers = []any{
		(*Salt_Hmac)(nil),
	}
	file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[2].OneofWrappers = []any{}
	file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[4].OneofWrappers = []any{
		(*PublicKey_SigningPublicKey)(nil),
		(*PublicKey_EncryptionPublicKey)(nil),
	}
	file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[6].OneofWrappers = []any{
		(*PrivateKey_SigningPrivateKey)(nil),
		(*PrivateKey_EncryptionPrivateKey)(nil),
	}
	file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes[15].OneofWrappers = []any{
		(*CryptoKeyPair_SigningKeyPair)(nil),
		(*CryptoKeyPair_EncryptionKeyPair)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDesc), len(file_com_digitalasset_canton_crypto_v30_crypto_proto_rawDesc)),
			NumEnums:      14,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_com_digitalasset_canton_crypto_v30_crypto_proto_goTypes,
		DependencyIndexes: file_com_digitalasset_canton_crypto_v30_crypto_proto_depIdxs,
		EnumInfos:         file_com_digitalasset_canton_crypto_v30_crypto_proto_enumTypes,
		MessageInfos:      file_com_digitalasset_canton_crypto_v30_crypto_proto_msgTypes,
	}.Build()
	File_com_digitalasset_canton_crypto_v30_crypto_proto = out.File
	file_com_digitalasset_canton_crypto_v30_crypto_proto_goTypes = nil
	file_com_digitalasset_canton_crypto_v30_crypto_proto_depIdxs = nil
}
