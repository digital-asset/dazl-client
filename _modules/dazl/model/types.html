<!DOCTYPE html>
<html lang="" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>dazl.model.types</title>
  

  <link rel="apple-touch-icon" sizes="180x180" href="../../../_static/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="../../../_static/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="../../../_static/favicon-16x16.png" sizes="16x16"/>
  <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="dazl 7.0.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 
</head>
<body>

   

  <header>
    dazl

  </header>
  <nav>
              
              
                
              
              
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../migrating.html">Migrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dazl.html">dazl package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

              

  </nav>
  <main>
    
  <h1>Source code for dazl.model.types</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Type system types</span>
<span class="sd">------------------</span>

<span class="sd">The :mod:`dazl.model.types` module contains the Python classes used to represent the DAML type</span>
<span class="sd">system.</span>

<span class="sd">+----------------------+---------------------------+</span>
<span class="sd">| DAML type            | Python type               |</span>
<span class="sd">+======================+===========================+</span>
<span class="sd">| ``Bool``             | ``bool``                  |</span>
<span class="sd">+----------------------+---------------------------+</span>
<span class="sd">| ``Int``              | ``int``                   |</span>
<span class="sd">+----------------------+---------------------------+</span>
<span class="sd">| ``Decimal``          | ``decimal.Decimal``       |</span>
<span class="sd">+----------------------+---------------------------+</span>
<span class="sd">| ``[a]``              | ``list``                  |</span>
<span class="sd">+----------------------+---------------------------+</span>

<span class="sd">.. autoclass:: Type</span>
<span class="sd">.. autoclass:: ScalarType</span>
<span class="sd">.. autoclass:: ListType</span>
<span class="sd">.. autoclass:: RecordType</span>
<span class="sd">.. autoclass:: VariantType</span>
<span class="sd">.. autoclass:: UnsupportedType</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">AbstractSet</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">NewType</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> \
    <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">LOG</span>
<span class="kn">from</span> <span class="nn">..damlast.daml_lf_1</span> <span class="kn">import</span> <span class="n">DottedName</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">ModuleRef</span><span class="p">,</span> <span class="n">PackageRef</span><span class="p">,</span> <span class="n">TypeConName</span>
<span class="kn">from</span> <span class="nn">..model.core</span> <span class="kn">import</span> <span class="n">ContractData</span><span class="p">,</span> <span class="n">Party</span>
<span class="kn">from</span> <span class="nn">..util.typing</span> <span class="kn">import</span> <span class="n">safe_cast</span><span class="p">,</span> <span class="n">safe_dict_cast</span><span class="p">,</span> <span class="n">safe_optional_cast</span>

<span class="n">DottedNameish</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>

<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.types_store</span> <span class="kn">import</span> <span class="n">PackageStore</span>


<span class="c1"># Reference to a ledger ID.</span>
<span class="n">LedgerId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;LedgerId&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="c1"># Reference to a package via a package identifier. The identifier is the ascii7</span>
<span class="c1"># lowercase hex-encoded hash of the package contents found in the DAML LF Archive.</span>
<span class="c1">#</span>
<span class="c1"># This is re-exported from the daml_lf_1 as PackageId for backwards compatibility, and will</span>
<span class="c1"># be removed in dazl 7.0.0.</span>
<span class="n">PackageId</span> <span class="o">=</span> <span class="n">PackageRef</span>

<span class="c1"># A set of PackageId.</span>
<span class="n">PackageIdSet</span> <span class="o">=</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="n">PackageId</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">type_ref</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeReference&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience method for creating a fully-qualified :class:`TypeReference`. A few formats are</span>
<span class="sd">    supported:</span>

<span class="sd">    &quot;packageId:module:entity&quot;</span>
<span class="sd">    &quot;module:entity@pkgid&quot;</span>
<span class="sd">    &quot;module.entity@pkgid&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Attempt to parse in an older format still used by Navigator for display purposes.</span>
    <span class="n">me</span><span class="p">,</span> <span class="n">is_at</span><span class="p">,</span> <span class="n">pkgid</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_at</span><span class="p">:</span>
        <span class="c1"># encourage people to use the new format</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">has_colon</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_colon</span><span class="p">:</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="n">pkg_ref</span> <span class="o">=</span> <span class="n">PackageRef</span><span class="p">(</span><span class="n">pkgid</span><span class="p">)</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="n">DottedName</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
        <span class="n">entity_name</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;could not parse as a template reference: </span><span class="si">{</span><span class="n">s</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">pkg_ref</span> <span class="o">=</span> <span class="n">PackageRef</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">module_name</span> <span class="o">=</span> <span class="n">DottedName</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
        <span class="n">entity_name</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">TypeReference</span><span class="p">(</span><span class="n">con</span><span class="o">=</span><span class="n">TypeConName</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="n">ModuleRef</span><span class="p">(</span><span class="n">pkg_ref</span><span class="p">,</span> <span class="n">module_name</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">entity_name</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">dotted_name</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">DottedNameish</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Sequence[str]&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sanitize a string or a tuple of strings to a dotted name.</span>

<span class="sd">    :param obj: A string or tuple of strings.</span>
<span class="sd">    :return: A tuple of strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;DottedName must be a non-None value&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Collection</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DottedName&#39;s components must all be strings&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;could not convert to a sequence of str: </span><span class="si">{obj!r}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NamedArgumentList</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple tuple to storing (name, value) pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">type_dispatch_table</span><span class="p">(</span>
        <span class="n">on_type_ref</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;TypeReference&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_type_var</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;TypeVariable&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_type_app</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;TypeApp&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_scalar</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;ScalarType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_contract_id</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;ContractIdType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_optional</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;OptionalType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_list</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;ListType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_text_map</span><span class="p">:</span> <span class="s1">&#39;Callable[[TextMapType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_record</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;RecordType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_variant</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;VariantType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">],</span>
        <span class="n">on_enum</span><span class="p">:</span> <span class="s1">&#39;Callable[[EnumType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_unsupported</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;UnsupportedType&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Type&#39;</span><span class="p">],</span> <span class="n">T_co</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="n">tt</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">TypeReference</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_type_ref</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">TypeVariable</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_type_var</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">TypeApp</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_type_app</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_scalar</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ContractIdType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_contract_id</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">OptionalType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_optional</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_list</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">TextMapType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_text_map</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">RecordType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_record</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">VariantType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_variant</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">EnumType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_enum</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">UnsupportedType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">on_unsupported</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># note to maintainers: if you modify the Type hierarchy, you must also maintain this</span>
            <span class="c1"># poor man&#39;s pattern match over the hierarchy</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Incomplete implementation of type_match! (when handling </span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unknown Type subclass: </span><span class="si">{</span><span class="n">tt</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_impl</span>


<span class="k">def</span> <span class="nf">scalar_type_dispatch_table</span><span class="p">(</span>
        <span class="n">on_unit</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_bool</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_text</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_int</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_decimal</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_party</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_date</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_datetime</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_timedelta</span><span class="p">:</span> <span class="s1">&#39;Callable[[], T_co]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Callable[[ScalarType], T_co]&#39;</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="n">tt</span><span class="p">:</span> <span class="n">ScalarType</span><span class="p">):</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">ScalarType</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_UNIT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_unit</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_BOOL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_bool</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_TEXT</span> <span class="ow">or</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_CHAR</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_text</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_INTEGER</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_int</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_DECIMAL</span> <span class="ow">or</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_NUMERIC</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_decimal</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_PARTY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_party</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_DATE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_date</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_DATETIME</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_datetime</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">SCALAR_TYPE_RELTIME</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">on_timedelta</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># note to maintainers: if you modify the set of ScalarType instances, you must also</span>
            <span class="c1"># maintain this poor man&#39;s pattern match over the hierarchy</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Incomplete implementation of scalar_type_dispatch_table! (when handling </span><span class="si">%r</span><span class="s1">)&#39;</span><span class="p">,</span>
                      <span class="n">tt</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unknown ScalarType: </span><span class="si">{</span><span class="n">tt</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_impl</span>


<div class="viewcode-block" id="Type"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.Type">[docs]</a><span class="k">class</span> <span class="nc">Type</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML-defined type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..pretty</span> <span class="kn">import</span> <span class="n">DAML_PRETTY_PRINTER</span>
        <span class="k">return</span> <span class="n">DAML_PRETTY_PRINTER</span><span class="o">.</span><span class="n">visit_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">TypeApp</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An application of one or more types to an open type.</span>

<span class="sd">    This is basically Type.Con in the Protobuf declaration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Type</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a Type is required here (got </span><span class="si">{</span><span class="n">body</span><span class="si">}</span><span class="s1"> instead)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arguments</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;at least one type argument is required in a TypeApp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;TypeApp(body=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="si">}</span><span class="s2">, arguments=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="si">}</span><span class="s2">&gt;&quot;</span>


<span class="k">class</span> <span class="nc">TypeVariable</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An unbound type in a Type expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;TypeVariable(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TypeVariable</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TypeReference</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">con</span><span class="p">:</span> <span class="s1">&#39;TypeConName&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">con</span> <span class="o">=</span> <span class="n">con</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">con</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TypeReference</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">con</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">con</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">con</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnresolvedTypeReference</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A reference that may or may not ultimately resolve to a type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;UnresolvedTypeReference(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s1">)&gt;&#39;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UnresolvedTypeReference</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="n">UnresolvedTypeReference</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">ConcreteType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="ScalarType"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.ScalarType">[docs]</a><span class="k">class</span> <span class="nc">ScalarType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML-defined type that represents a simple scalar value. You should not need to ever</span>
<span class="sd">    construct instances of this directly; all scalar types are builtins.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an object that references a scalar DAML type.</span>

<span class="sd">        :param name: The name of this type as it is known in DAML.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the DAML name of this type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="n">ScalarType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ScalarType</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span></div>


<span class="k">class</span> <span class="nc">_BuiltInParameterizedType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience class that encapsulates commonalities for the built-in types that have one type</span>
<span class="sd">    parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;type_parameter&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_parameter</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_parameter</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">type_parameter</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">py_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">py_type</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type_parameter</span><span class="si">!r}</span><span class="s1">)&gt;&#39;</span>


<span class="k">class</span> <span class="nc">ContractIdType</span><span class="p">(</span><span class="n">_BuiltInParameterizedType</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="ListType"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.ListType">[docs]</a><span class="k">class</span> <span class="nc">ListType</span><span class="p">(</span><span class="n">_BuiltInParameterizedType</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="k">class</span> <span class="nc">TypeRefType</span><span class="p">(</span><span class="n">_BuiltInParameterizedType</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">TextMapType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML-defined TextMap.</span>

<span class="sd">    Instance attributes:</span>

<span class="sd">    .. attribute: TextMapType.value_type</span>

<span class="sd">        The type of values in this map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;value_type&#39;</span><span class="p">,</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">py_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">py_type</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="si">!r}</span><span class="s1">)&gt;&#39;</span>


<span class="k">class</span> <span class="nc">GenMapType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML-defined GenMap.</span>

<span class="sd">    Instance attributes:</span>

<span class="sd">    .. attribute: TextMapType.key_type</span>

<span class="sd">        The type of keys in this map.</span>

<span class="sd">    .. attribute: TextMapType.value_type</span>

<span class="sd">        The type of values in this map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;key_type&#39;</span><span class="p">,</span> <span class="s1">&#39;value_type&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">key_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">py_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">py_type</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="si">!r}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="si">!r}</span><span class="s1">)&gt;&#39;</span>


<span class="k">class</span> <span class="nc">OptionalType</span><span class="p">(</span><span class="n">_BuiltInParameterizedType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML-defined Optional.</span>

<span class="sd">    Instance attributes:</span>

<span class="sd">    .. attribute: OptionalType.type_parameter</span>

<span class="sd">        The type of value in the Optional.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">UpdateType</span><span class="p">(</span><span class="n">_BuiltInParameterizedType</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ForAllType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_vars</span><span class="p">,</span> <span class="n">body_type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_vars</span> <span class="o">=</span> <span class="n">type_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body_type</span> <span class="o">=</span> <span class="n">body_type</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;ForAllType(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type_vars</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">body_type</span><span class="si">}</span><span class="s1">)&gt;&#39;</span>


<span class="k">class</span> <span class="nc">_CompositeDataType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Either a :class:`RecordType` (product type) or a :class:`VariantType` (sum type).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">named_args</span><span class="p">:</span> <span class="s1">&#39;NamedArgumentList&#39;</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;Optional[TypeReference]&#39;</span><span class="p">,</span>
                 <span class="n">type_args</span><span class="p">:</span> <span class="s1">&#39;Sequence[TypeVariable]&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">_CompositeDataType</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;_CompositeDataType cannot be constructed&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">named_args</span><span class="p">,</span> <span class="n">NamedArgumentList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;NamedArgumentList required here&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TypeReference</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;name must be a TypeReference or None&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">named_args</span> <span class="o">=</span> <span class="n">named_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">field_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value_type</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;field or constructor </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s1"> not found in </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">py_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;(anonymous)&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">full_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">((</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_args</span><span class="p">))</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">py_type</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">full_name</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">named_args</span><span class="si">}</span><span class="s1">&gt;&#39;</span>


<span class="k">class</span> <span class="nc">FunctionType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a DAML function signature.</span>

<span class="sd">    Instances of this type aren&#39;t practically usable from this library. They are merely recorded in</span>
<span class="sd">    order to faithfully pretty-print metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">result</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
        <span class="k">with</span> <span class="n">StringIO</span><span class="p">()</span> <span class="k">as</span> <span class="n">buf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
                <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; -&gt; &#39;</span><span class="p">)</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;FunctionType(</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">)&gt;&#39;</span>


<div class="viewcode-block" id="RecordType"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.RecordType">[docs]</a><span class="k">class</span> <span class="nc">RecordType</span><span class="p">(</span><span class="n">_CompositeDataType</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">as_args_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_args</span></div>


<div class="viewcode-block" id="VariantType"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.VariantType">[docs]</a><span class="k">class</span> <span class="nc">VariantType</span><span class="p">(</span><span class="n">_CompositeDataType</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">as_args_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_args</span>

    <span class="k">def</span> <span class="nf">_find_ctor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constructor_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_type</span><span class="p">(</span><span class="n">constructor_name</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">EnumType</span><span class="p">(</span><span class="n">ConcreteType</span><span class="p">):</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s1">&#39;constructors&#39;</span><span class="p">,</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;Optional[TypeReference]&#39;</span><span class="p">,</span> <span class="n">constructors</span><span class="p">:</span> <span class="s1">&#39;Collection[str]&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constructors</span> <span class="o">=</span> <span class="n">constructors</span>


<div class="viewcode-block" id="UnsupportedType"><a class="viewcode-back" href="../../../dazl.model.html#dazl.model.types.UnsupportedType">[docs]</a><span class="k">class</span> <span class="nc">UnsupportedType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DAML type that is currently unparseable by the Python client library.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;UnsupportedType(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">)&gt;&#39;</span></div>



<span class="k">class</span> <span class="nc">Template</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Definition of a contract template.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data_type</span><span class="p">:</span> <span class="s1">&#39;RecordType&#39;</span><span class="p">,</span>
            <span class="n">key_type</span><span class="p">:</span> <span class="s1">&#39;Optional[Type]&#39;</span><span class="p">,</span>
            <span class="n">choices</span><span class="p">:</span> <span class="s1">&#39;Collection[TemplateChoice]&#39;</span><span class="p">,</span>
            <span class="n">observers</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
            <span class="n">signatories</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
            <span class="n">agreement</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">,</span>
            <span class="n">ensure</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">RecordType</span><span class="p">)</span> <span class="ow">or</span> <span class="n">data_type</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;data_type is required and must be a named record type &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;(got </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">safe_cast</span><span class="p">(</span><span class="n">RecordType</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span> <span class="o">=</span> <span class="n">safe_optional_cast</span><span class="p">(</span><span class="n">Type</span><span class="p">,</span> <span class="n">key_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">choices</span> <span class="o">=</span> <span class="n">choices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observers</span> <span class="o">=</span> <span class="n">observers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_signatories</span> <span class="o">=</span> <span class="n">signatories</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_agreement</span> <span class="o">=</span> <span class="n">agreement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure</span> <span class="o">=</span> <span class="n">ensure</span>


<span class="k">class</span> <span class="nc">TemplateChoice</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;consuming&#39;</span><span class="p">,</span> <span class="s1">&#39;data_type&#39;</span><span class="p">,</span> <span class="s1">&#39;return_type&#39;</span><span class="p">,</span> <span class="s1">&#39;_controllers&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">consuming</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">controllers</span><span class="p">:</span> <span class="s1">&#39;Expr&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consuming</span> <span class="o">=</span> <span class="n">consuming</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">data_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_type</span> <span class="o">=</span> <span class="n">return_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_controllers</span> <span class="o">=</span> <span class="n">controllers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span>

    <span class="k">def</span> <span class="nf">controllers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdata</span><span class="p">:</span> <span class="n">ContractData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Collection</span><span class="p">[</span><span class="n">Party</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return every :class:`Party` that can exercise this choice given the specified contract data.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">as_commands</span><span class="p">(</span><span class="n">commands_ish</span><span class="p">,</span> <span class="n">allow_callables</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts something that is either ``None``, a single :class:`Command`, or an iterable over</span>
<span class="sd">    :class:`Command` objects to a ``list`` of :class:`Command`.</span>

<span class="sd">    :param commands_ish:</span>
<span class="sd">        Something that might be construed as either a :class:`Command` or an iterable over</span>
<span class="sd">        :class:`Command`.</span>
<span class="sd">    :param allow_callables:</span>
<span class="sd">        If callables are encountered, invoke them and expect them to return something that can be</span>
<span class="sd">        easily serialized to a :class:`Command`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.writing</span> <span class="kn">import</span> <span class="n">Command</span>

    <span class="k">if</span> <span class="n">commands_ish</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">commands_ish</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">commands_ish</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="n">allow_callables</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">commands_ish</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_commands</span><span class="p">(</span><span class="n">commands_ish</span><span class="p">(),</span> <span class="n">allow_callables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># assume this is some kind of iterable structure, where everything needs to be a Command</span>
    <span class="n">cmds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands_ish</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">allow_callables</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">command</span><span class="p">):</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_commands</span><span class="p">(</span><span class="n">command</span><span class="p">(),</span> <span class="n">allow_callables</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">command</span><span class="si">!r}</span><span class="s1"> is not a Command&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">as_contract_id</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">template_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert something that resembles a contract ID to a :class:`ContractId` or</span>
<span class="sd">    :class:`RelativeContractRef`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">ContractId</span>

    <span class="k">if</span> <span class="n">cid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cid is required&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ContractId</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">template_id</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cid</span><span class="p">,</span> <span class="n">ContractId</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cid</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Could not serialize an object to a contract ID: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cid</span><span class="p">))</span>


<span class="n">SCALAR_TYPE_UNIT</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Unit&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_BOOL</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Bool&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_CHAR</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Char&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_INTEGER</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Integer&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_DECIMAL</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Decimal&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_NUMERIC</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Numeric&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_TEXT</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Text&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_PARTY</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Party&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_RELTIME</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;RelTime&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_DATE</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_TIME</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_ANY</span> <span class="o">=</span> <span class="n">ScalarType</span><span class="p">(</span><span class="s1">&#39;Any&#39;</span><span class="p">)</span>
<span class="n">SCALAR_TYPE_DATETIME</span> <span class="o">=</span> <span class="n">SCALAR_TYPE_TIME</span>

<span class="n">ScalarType</span><span class="o">.</span><span class="n">BUILTINS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">SCALAR_TYPE_BOOL</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_CHAR</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_INTEGER</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_DECIMAL</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_NUMERIC</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_TEXT</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_PARTY</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_RELTIME</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_DATE</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_TIME</span><span class="p">,</span>
    <span class="n">SCALAR_TYPE_ANY</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">TypeEvaluationContext</span><span class="p">:</span>
    <span class="n">references</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TypeConName</span><span class="p">,</span> <span class="n">ConcreteType</span><span class="p">]</span>
    <span class="n">variables</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TypeVariable</span><span class="p">,</span> <span class="n">Type</span><span class="p">]</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TypeReference</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;references&#39;</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_store</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">store</span><span class="p">:</span> <span class="s1">&#39;PackageStore&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeEvaluationContext&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">types</span><span class="p">(),</span> <span class="p">{},</span> <span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">references</span><span class="p">:</span> <span class="s1">&#39;Mapping[TypeConName, ConcreteType]&#39;</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="n">safe_dict_cast</span><span class="p">(</span><span class="n">TypeConName</span><span class="p">,</span> <span class="n">ConcreteType</span><span class="p">,</span> <span class="n">references</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">safe_dict_cast</span><span class="p">(</span><span class="n">TypeVariable</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">append_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TypeReference</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeEvaluationContext&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TypeEvaluationContext</span><span class="p">(</span>
            <span class="n">references</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="nb">tuple</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">component</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">resolve_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="n">TypeVariable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">with_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">TypeVariable</span><span class="p">,</span> <span class="n">Type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeEvaluationContext&#39;</span><span class="p">:</span>
        <span class="n">confirmed_new_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">new_var</span><span class="p">,</span> <span class="n">new_var_value</span> <span class="ow">in</span> <span class="n">new_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">new_var</span> <span class="o">==</span> <span class="n">new_var_value</span><span class="p">:</span>
                <span class="c1"># TODO: Why do these cases happen?</span>
                <span class="k">continue</span>
            <span class="n">confirmed_new_vars</span><span class="p">[</span><span class="n">new_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var_value</span>

        <span class="k">return</span> <span class="n">TypeEvaluationContext</span><span class="p">(</span>
            <span class="n">references</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="o">**</span><span class="n">confirmed_new_vars</span><span class="p">},</span>
            <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">type_evaluate_dispatch</span><span class="p">(</span>
        <span class="n">on_scalar</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, ScalarType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_contract_id</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext,  ContractIdType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_optional</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, OptionalType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_list</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, ListType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_text_map</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, TextMapType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_record</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, RecordType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_variant</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, VariantType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_enum</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, EnumType], T_co]&#39;</span><span class="p">,</span>
        <span class="n">on_unsupported</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, UnsupportedType], T_co]&#39;</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, Type], T_co]&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produce a function that defers handling of core types to the passed in functions.</span>

<span class="sd">    The cases of :class:`TypeReference, :class:`TypeApp`, and :class:`TypeVariable` are handled</span>
<span class="sd">    automatically. Note, though that ultimately type evaluation is only performed at one level</span>
<span class="sd">    deep, and the produced function may need to be called multiple types at multiple depths of an</span>
<span class="sd">    object or type hierarchy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_impl</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tt</span><span class="p">):</span>
        <span class="n">resolve_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">TypeReference</span><span class="p">,</span> <span class="n">TypeVariable</span><span class="p">,</span> <span class="n">TypeApp</span><span class="p">)):</span>
            <span class="n">context</span><span class="p">,</span> <span class="n">tt</span> <span class="o">=</span> <span class="n">single_reduce</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>
            <span class="n">resolve_depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">resolve_depth</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;hit our max resolve depth, which is probably not so great&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;T_co&#39;</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>

        <span class="n">context</span><span class="p">,</span> <span class="n">tt</span> <span class="o">=</span> <span class="n">annotate_context</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">type_dispatch_table</span><span class="p">(</span>
            <span class="n">error</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">st</span><span class="p">:</span> <span class="n">on_scalar</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">ct</span><span class="p">:</span> <span class="n">on_contract_id</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ct</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">ot</span><span class="p">:</span> <span class="n">on_optional</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ot</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">lt</span><span class="p">:</span> <span class="n">on_list</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">lt</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">mt</span><span class="p">:</span> <span class="n">on_text_map</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">mt</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">rt</span><span class="p">:</span> <span class="n">on_record</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">rt</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">vt</span><span class="p">:</span> <span class="n">on_variant</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">vt</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">et</span><span class="p">:</span> <span class="n">on_enum</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">et</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">ut</span><span class="p">:</span> <span class="n">on_unsupported</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">tt</span><span class="p">))(</span><span class="n">tt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_impl</span>


<span class="k">def</span> <span class="nf">_type_evaluate_dispatch_error</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">type_evaluate_dispatch_default_error</span><span class="p">(</span>
        <span class="n">on_scalar</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, ScalarType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_contract_id</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext,  ContractIdType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_optional</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext,  OptionalType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_list</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, ListType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_text_map</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, TextMapType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_record</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, RecordType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_variant</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, VariantType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_enum</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, EnumType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">,</span>
        <span class="n">on_unsupported</span><span class="p">:</span> <span class="s1">&#39;Callable[[TypeEvaluationContext, UnsupportedType], T_co]&#39;</span> <span class="o">=</span> <span class="n">_type_evaluate_dispatch_error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">type_evaluate_dispatch</span><span class="p">(</span>
        <span class="n">on_scalar</span><span class="p">,</span> <span class="n">on_contract_id</span><span class="p">,</span> <span class="n">on_optional</span><span class="p">,</span> <span class="n">on_list</span><span class="p">,</span> <span class="n">on_text_map</span><span class="p">,</span> <span class="n">on_record</span><span class="p">,</span> <span class="n">on_variant</span><span class="p">,</span>
        <span class="n">on_enum</span><span class="p">,</span> <span class="n">on_unsupported</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">single_reduce</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">TypeEvaluationContext</span><span class="p">,</span> <span class="n">tt</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Tuple[TypeEvaluationContext, Type]&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a single substitution/reduction/unwrapping. The context may be augmented with additional</span>
<span class="sd">    variables if a TypeApp is encountered.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="n">context</span><span class="p">,</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">reduce_app</span><span class="p">(</span><span class="n">ta</span><span class="p">:</span> <span class="n">TypeApp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Tuple[TypeEvaluationContext, Type]&#39;</span><span class="p">:</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="n">ta</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">con</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ta</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">TypeReference</span><span class="p">)</span> <span class="k">else</span> <span class="n">ta</span><span class="o">.</span><span class="n">body</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="p">(</span><span class="n">RecordType</span><span class="p">,</span> <span class="n">VariantType</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t apply types to non-generic data structures&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">with_vars</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">type_args</span><span class="p">,</span> <span class="n">ta</span><span class="o">.</span><span class="n">arguments</span><span class="p">))),</span> <span class="n">ta</span><span class="o">.</span><span class="n">body</span>

    <span class="k">return</span> <span class="n">type_dispatch_table</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">tr</span><span class="p">:</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="n">tr</span><span class="o">.</span><span class="n">con</span><span class="p">]),</span>
        <span class="k">lambda</span> <span class="n">tv</span><span class="p">:</span> <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">resolve_var</span><span class="p">(</span><span class="n">tv</span><span class="p">)),</span>
        <span class="n">reduce_app</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">,</span>
        <span class="n">identity</span><span class="p">)(</span><span class="n">tt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">annotate_context</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">TypeEvaluationContext</span><span class="p">,</span> <span class="n">tt</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">TypeEvaluationContext</span><span class="p">,</span> <span class="n">Type</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="n">context</span><span class="p">,</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">annotate_path</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">RecordType</span><span class="p">,</span> <span class="n">VariantType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">TypeEvaluationContext</span><span class="p">,</span> <span class="n">Type</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">append_path</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">t</span>

    <span class="k">return</span> <span class="n">type_dispatch_table</span><span class="p">(</span>
        <span class="n">error</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span>
        <span class="n">annotate_path</span><span class="p">,</span> <span class="n">annotate_path</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">identity</span><span class="p">)(</span><span class="n">tt</span><span class="p">)</span>


<span class="c1"># types that can be used to refer to templates</span>
<span class="n">TemplateNameLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TypeReference</span><span class="p">,</span> <span class="n">UnresolvedTypeReference</span><span class="p">,</span> <span class="n">Template</span><span class="p">]</span>
</pre></div>

  </main>

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'',
            VERSION:'7.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <footer> 
  </footer>
</body>
</html>